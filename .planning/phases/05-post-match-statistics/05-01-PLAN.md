---
phase: 05-post-match-statistics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - lib/db/statistics.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FormationPosition has side field to track home/away team"
    - "Player career statistics can be queried (goals, assists, appearances, wins, losses, draws)"
    - "Statistics queries work for completed matches"
    - "Leaderboards show top performers"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "FormationPosition with side field"
      contains: "side String"
    - path: "lib/db/statistics.ts"
      provides: "Statistics aggregation functions for individual players"
      exports: ["getPlayerStats", "getTopScorers", "getTopAssisters", "getTopAppearances", "getTopWins", "getTopLosses"]
  key_links:
    - from: "lib/db/statistics.ts"
      to: "FormationPosition"
      via: "side field for team assignment"
      pattern: "side.*home|away"
    - from: "lib/db/statistics.ts"
      to: "prisma.goal"
      via: "aggregation queries"
      pattern: "prisma\\.goal"
---

<objective>
Add side field to FormationPosition to track home/away team assignment, then implement statistics aggregation functions for individual player statistics.

Purpose: Enable the app to calculate which team each player was on, then aggregate player statistics including wins, losses, and draws.
Output: Updated Prisma schema with side field, lib/db/statistics.ts with aggregation queries.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns from Phase 4
@lib/db/goals.ts
@lib/db/player-ratings.ts
@lib/db/player-participation.ts
@lib/db/match-lifecycle.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add side field to FormationPosition schema</name>
  <files>prisma/schema.prisma</files>
  <action>
    Add a `side` field to the FormationPosition model to track whether the player is on home or away team:
    
    ```prisma
    model FormationPosition {
      id            String  @id @default(cuid())
      formationId   String  @map("formation_id")
      playerId      String? @map("player_id")
      positionX     Int     @map("position_x")
      positionY     Int     @map("position_y")
      positionLabel String  @map("position_label")
      isSubstitute  Boolean @default(false) @map("is_substitute")
      side          String? @map("side")  // NEW: 'home' | 'away'
      
      // ... relations
    }
    ```
    
    The field should:
    - Be a String with values 'home' or 'away' (or null for substitutes)
    - Be set when the match is completed based on positionX (< 5 = home, >= 5 = away)
    
    After modifying the schema, run `npx prisma db push` to apply the migration.
  </action>
  <verify>
    npx prisma generate succeeds
    npx prisma db push succeeds
    grep -n "side.*String" prisma/schema.prisma shows the new field in FormationPosition
  </verify>
  <done>
    FormationPosition model has side: String? field
    Database schema updated via prisma db push
    Prisma client regenerated
  </done>
</task>

<task type="auto">
  <name>Task 2: Update match completion to set side for each player</name>
  <files>lib/db/match-lifecycle.ts</files>
  <action>
    Update the match completion logic to set the side field for each FormationPosition:
    
    In `completeMatch` or `inputFinalResults` functions:
    - For each FormationPosition in the match's formation
    - Calculate side based on positionX:
      - positionX < 5 → 'home'
      - positionX >= 5 → 'away'
    - Update the FormationPosition record with the side value
    
    This ensures that when a match is completed, we have a permanent record of which team each player was on.
    
    **Example:**
    ```typescript
    // In completeMatch function
    const formation = await prisma.formation.findUnique({
      where: { matchId },
      include: { positions: true }
    })
    
    for (const position of formation.positions) {
      const side = position.positionX < 5 ? 'home' : 'away'
      await prisma.formationPosition.update({
        where: { id: position.id },
        data: { side }
      })
    }
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "side" lib/db/match-lifecycle.ts shows side assignment logic
  </verify>
  <done>
    Match completion sets side for each FormationPosition
    Side is calculated from positionX (< 5 = home, >= 5 = away)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create statistics aggregation module</name>
  <files>lib/db/statistics.ts</files>
  <action>
    Create lib/db/statistics.ts with aggregation functions for player statistics:
    
    **Type definitions:**
    ```typescript
    export interface PlayerStats {
      player_id: string
      player_name: string
      player_surname?: string
      player_nickname?: string
      player_avatar?: string
      goals: number
      assists: number
      appearances: number
      wins: number
      losses: number
      draws: number
      avg_rating: number | null
      total_ratings: number
    }
    
    export interface PlayerLeaderboardEntry {
      player_id: string
      player_name: string
      player_nickname?: string
      player_avatar?: string
      value: number
    }
    ```
    
    **Functions to implement:**
    
    1. `getPlayerStats(playerId: string, teamId?: string): Promise<PlayerStats | null>`
       - Count goals from Goal where scorerId = playerId (exclude own goals)
       - Count assists from Goal where assisterId = playerId
       - Count appearances from MatchPlayer where played = true in COMPLETED matches
       - Count wins: matches where player was on home side and homeScore > awayScore, OR on away side and awayScore > homeScore
       - Count losses: opposite of wins
       - Count draws: matches where homeScore = awayScore
       - Calculate average rating from PlayerRating in COMPLETED matches
       - If teamId provided, filter stats to that team only
    
    2. `getTopScorers(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Query goals scored (exclude own goals) for players in team
       - Group by player, count goals
       - Order by goals desc, return top N (default 5)
    
    3. `getTopAssisters(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Query assists from Goal where assisterId IS NOT NULL
       - Group by player, count assists
       - Order by assists desc, return top N (default 5)
    
    4. `getTopAppearances(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Query appearances from MatchPlayer where played = true
       - Group by player, count appearances
       - Order by appearances desc, return top N (default 5)
    
    5. `getTopWins(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - For each player, count matches won (based on side and match score)
       - Order by wins desc, return top N (default 5)
    
    6. `getTopLosses(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - For each player, count matches lost (based on side and match score)
       - Order by losses desc, return top N (default 5)
    
    7. `getTopRatedPlayers(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Query PlayerRatings for players in team's matches
       - Calculate average rating per player
       - Order by avg rating desc, return top N (default 5)
       - Only include players with at least 3 ratings
    
    **Implementation notes:**
    - Use Prisma's $queryRaw for complex win/loss calculations
    - Use MatchStatus.COMPLETED for all statistics
    - Handle null cases gracefully
    - Use 'use server' at the top
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "getPlayerStats\|getTopScorers\|getTopWins\|getTopLosses" lib/db/statistics.ts shows all functions
  </verify>
  <done>
    lib/db/statistics.ts created with 7 exported functions
    All functions properly typed with TypeScript
    Win/loss calculation uses FormationPosition.side
  </done>
</task>

</tasks>

<verification>
1. Run `npx prisma generate` to regenerate Prisma client
2. Run `npx tsc --noEmit` to verify TypeScript compilation
3. Verify FormationPosition.side field exists
4. Verify statistics.ts exports all required functions
5. Verify win/loss calculation logic is correct
</verification>

<success_criteria>
- FormationPosition.side field exists for team assignment
- Match completion sets side for each player position
- lib/db/statistics.ts provides aggregation queries for player statistics
- Win/loss/draw stats calculated based on side and match score
- All leaderboards work (scorers, assists, appearances, wins, losses, ratings)
</success_criteria>

<output>
After completion, create `.planning/phases/05-post-match-statistics/05-01-SUMMARY.md`
</output>
