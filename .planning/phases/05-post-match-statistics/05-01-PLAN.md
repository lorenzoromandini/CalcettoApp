---
phase: 05-post-match-statistics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - lib/db/match-lifecycle.ts
  - components/players/role-selector.tsx
  - lib/validations/player.ts
  - lib/db/statistics.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "FormationPosition has side field to track home/away team"
    - "RoleSelector separates primary role from other roles"
    - "Player career statistics can be queried (goals, assists, appearances, wins, losses, draws)"
    - "Goals conceded tracked only for goalkeepers playing in GK position"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "FormationPosition with side field"
      contains: "side String"
    - path: "components/players/role-selector.tsx"
      provides: "Primary role + other roles selector"
      contains: "primaryRole"
    - path: "lib/db/statistics.ts"
      provides: "Statistics aggregation functions"
      exports: ["getPlayerStats", "getTopScorers", "getTopAssists", "getTopAppearances", "getTopWins", "getTopLosses", "getTopRatedPlayers", "getTopGoalsConceded"]
  key_links:
    - from: "lib/db/statistics.ts"
      to: "FormationPosition"
      via: "side + positionLabel for goalkeeper"
      pattern: "side.*home|away|positionLabel.*GK"
    - from: "role-selector.tsx"
      to: "Player.roles"
      via: "roles[0] = primary, roles[1:] = others"
---

<objective>
Add side field to FormationPosition, update RoleSelector to distinguish primary role, and implement all statistics aggregation functions including goals conceded for goalkeepers.

Purpose: Enable team assignment tracking, role separation, and complete player statistics with wins/losses/draws and goals conceded.
Output: Schema update, RoleSelector redesign, complete statistics module.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns
@lib/db/goals.ts
@lib/db/player-ratings.ts
@lib/db/player-participation.ts
@lib/db/match-lifecycle.ts
@lib/formations/index.ts
@components/players/role-selector.tsx
@lib/validations/player.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add side field to FormationPosition schema</name>
  <files>prisma/schema.prisma</files>
  <action>
    Add a `side` field to the FormationPosition model:
    
    ```prisma
    model FormationPosition {
      id            String  @id @default(cuid())
      formationId   String  @map("formation_id")
      playerId      String? @map("player_id")
      positionX     Int     @map("position_x")
      positionY     Int     @map("position_y")
      positionLabel String  @map("position_label")
      isSubstitute  Boolean @default(false) @map("is_substitute")
      side          String? @map("side")  // NEW: 'home' | 'away'
      
      formation Formation @relation(fields: [formationId], references: [id], onDelete: Cascade)
      player    Player?   @relation(fields: [playerId], references: [id], onDelete: SetNull)

      @@unique([formationId, positionX, positionY])
      @@index([formationId])
      @@index([playerId])
      @@map("formation_positions")
    }
    ```
    
    The field should:
    - Be a String with values 'home' or 'away' (or null for substitutes)
    - Be set when the match is completed based on positionX (< 5 = home, >= 5 = away)
    
    After modifying the schema, run `npx prisma db push` to apply.
  </action>
  <verify>
    npx prisma generate succeeds
    npx prisma db push succeeds
    grep -n "side.*String" prisma/schema.prisma shows the new field in FormationPosition
  </verify>
  <done>
    FormationPosition model has side: String? field
    Database schema updated
    Prisma client regenerated
  </done>
</task>

<task type="auto">
  <name>Task 2: Update match completion to set side for each player</name>
  <files>lib/db/match-lifecycle.ts</files>
  <action>
    Update the match completion logic to set the side field for each FormationPosition:
    
    In `completeMatch` or `inputFinalResults` functions:
    - For each FormationPosition in the match's formation
    - Calculate side based on positionX:
      - positionX < 5 → 'home'
      - positionX >= 5 → 'away'
    - Update the FormationPosition record with the side value
    
    This ensures that when a match is completed, we have a permanent record of which team each player was on.
    
    **Example:**
    ```typescript
    const formation = await prisma.formation.findUnique({
      where: { matchId },
      include: { positions: true }
    })
    
    for (const position of formation.positions) {
      const side = position.positionX < 5 ? 'home' : 'away'
      await prisma.formationPosition.update({
        where: { id: position.id },
        data: { side }
      })
    }
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "side" lib/db/match-lifecycle.ts shows side assignment logic
  </verify>
  <done>
    Match completion sets side for each FormationPosition
    Side is calculated from positionX (< 5 = home, >= 5 = away)
  </done>
</task>

<task type="auto">
  <name>Task 3: Update RoleSelector with primary role and other roles</name>
  <files>components/players/role-selector.tsx, lib/validations/player.ts, messages/it.json, messages/en.json</files>
  <action>
    Redesign RoleSelector to separate primary role from other roles:
    
    **UI Structure:**
    ```
    ┌─────────────────────────────────────┐
    │ Ruolo principale *                  │
    │ [POR] [DIF] [CEN] [ATT]             │  ← Single select (required)
    ├─────────────────────────────────────┤
    │ Altri ruoli (opzionale)             │
    │ [POR] [DIF] [CEN] [ATT]             │  ← Multi-select (optional)
    └─────────────────────────────────────┘
    ```
    
    **Props update:**
    ```typescript
    interface RoleSelectorProps {
      primaryRole: PlayerRole | null      // Changed from value[]
      otherRoles: PlayerRole[]            // New
      onPrimaryRoleChange: (role: PlayerRole) => void
      onOtherRolesChange: (roles: PlayerRole[]) => void
      disabled?: boolean
    }
    ```
    
    **Data storage:**
    - `roles[0]` = primary role (always present)
    - `roles[1:]` = other roles (optional)
    
    **Update lib/validations/player.ts:**
    - Ensure at least one role (primary) is required
    - Validation: roles array must have at least 1 element
    
    **Update player-form.tsx:**
    - Pass primaryRole = form.watch('roles.0')
    - Pass otherRoles = form.watch('roles').slice(1)
    - On primary change: set roles to [newPrimary, ...otherRoles]
    - On other roles change: set roles to [primaryRole, ...newOtherRoles]
    
    **Add translations:**
    ```json
    // it.json
    "primary_role": "Ruolo principale",
    "other_roles": "Altri ruoli (opzionale)"
    // en.json
    "primary_role": "Primary role",
    "other_roles": "Other roles (optional)"
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "primaryRole\|otherRoles" components/players/role-selector.tsx shows new structure
  </verify>
  <done>
    RoleSelector has two sections: primary role (single) and other roles (multi)
    roles[0] = primary role, roles[1:] = other roles
    Italian translations added
  </done>
</task>

<task type="auto">
  <name>Task 4: Create complete statistics aggregation module</name>
  <files>lib/db/statistics.ts</files>
  <action>
    Create lib/db/statistics.ts with all aggregation functions:
    
    **Type definitions:**
    ```typescript
    export interface PlayerStats {
      player_id: string
      player_name: string
      player_surname?: string
      player_nickname?: string
      player_avatar?: string
      goals: number
      assists: number
      appearances: number
      wins: number
      losses: number
      draws: number
      goals_conceded: number | null  // Only for goalkeepers
      avg_rating: number | null
      total_ratings: number
    }
    
    export interface PlayerLeaderboardEntry {
      player_id: string
      player_name: string
      player_nickname?: string
      player_avatar?: string
      value: number
    }
    ```
    
    **Functions to implement:**
    
    1. `getPlayerStats(playerId: string, teamId?: string): Promise<PlayerStats | null>`
       - goals: Count from Goal where scorerId = playerId (exclude own goals)
       - assists: Count from Goal where assisterId = playerId
       - appearances: Count from MatchPlayer where played = true in COMPLETED matches
       - wins/losses/draws: Based on FormationPosition.side and match scores
       - goals_conceded: Only if 'goalkeeper' in player.roles (any position in array) AND played in GK position
         - Home GK: goals_conceded = awayScore
         - Away GK: goals_conceded = homeScore
       - avg_rating: Average from PlayerRating in COMPLETED matches
    
    2. `getTopScorers(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default, order by goals desc
    
    3. `getTopAssisters(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default
    
    4. `getTopAppearances(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default
    
    5. `getTopWins(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default
    
    6. `getTopLosses(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default
    
    7. `getTopRatedPlayers(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 by default, minimum 3 ratings required
    
    8. `getTopGoalsConceded(teamId: string, limit?: number): Promise<PlayerLeaderboardEntry[]>`
       - Top 3 goalkeepers with FEWEST goals conceded
       - Only players where roles[0] = 'goalkeeper'
       - Only when playing in GK position (positionLabel = 'GK')
       - Order by goals_conceded ASC (fewer = better)
    
    9. `getMatchScorers(matchId: string): Promise<{ player_name: string; count: number }[]>`
       - For match history cards
    
    **Win/Loss/Draw calculation:**
    ```sql
    -- Win: player on home side AND homeScore > awayScore
    --      OR player on away side AND awayScore > homeScore
    -- Loss: opposite of win
    -- Draw: homeScore = awayScore
    ```
    
    **Goals conceded calculation:**
    ```sql
    -- Find player in GK position
    -- Check if 'goalkeeper' in player.roles (any position in array)
    -- If side = 'home': goals_conceded = awayScore
    -- If side = 'away': goals_conceded = homeScore
    ```
    
    **Note:** Goalkeeper can be primary OR secondary role — if 'goalkeeper' is anywhere in the roles array and player plays in GK position, goals conceded are tracked.
    
    **Implementation notes:**
    - Use Prisma $queryRaw for complex queries
    - Use MatchStatus.COMPLETED for all stats
    - Handle null cases gracefully
    - Use 'use server' at top
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "getPlayerStats\|getTopScorers\|getTopWins\|getTopGoalsConceded" lib/db/statistics.ts shows all functions
  </verify>
  <done>
    lib/db/statistics.ts created with 9 exported functions
    All stats include wins, losses, draws
    Goals conceded only for GKs with primary role = goalkeeper
    All leaderboards return top 3 by default
  </done>
</task>

</tasks>

<verification>
1. Run `npx prisma generate` to regenerate Prisma client
2. Run `npx tsc --noEmit` to verify TypeScript compilation
3. Verify FormationPosition.side field exists
4. Verify RoleSelector shows primary role separate from other roles
5. Verify statistics.ts exports all 9 functions
6. Verify goals_conceded logic is correct
</verification>

<success_criteria>
- FormationPosition.side field exists for team assignment
- Match completion sets side for each player position
- RoleSelector separates primary role (required) from other roles (optional)
- roles[0] = primary role, roles[1:] = other roles
- lib/db/statistics.ts provides all aggregation functions
- Win/loss/draw stats calculated based on side and match score
- Goals conceded only for players with 'goalkeeper' in roles array (primary or secondary) playing in GK position
- All leaderboards return top 3
</success_criteria>

<output>
After completion, create `.planning/phases/05-post-match-statistics/05-01-SUMMARY.md`
</output>
