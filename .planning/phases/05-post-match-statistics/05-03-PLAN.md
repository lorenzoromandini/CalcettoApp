---
phase: 05-post-match-statistics
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - package.json
  - lib/db/match-photos.ts
  - hooks/use-match-photos.ts
  - components/matches/match-photo-uploader.tsx
  - components/matches/match-photo-gallery.tsx
  - messages/it.json
  - messages/en.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can upload match photos with client-side compression"
    - "Uploaded photos appear in match gallery"
    - "Photos are compressed before upload (max 1MB)"
    - "User can delete photos from match gallery"
  artifacts:
    - path: "lib/db/match-photos.ts"
      provides: "Photo CRUD operations"
      exports: ["addMatchPhoto", "deleteMatchPhoto", "getMatchPhotos"]
    - path: "components/matches/match-photo-uploader.tsx"
      provides: "Photo upload UI with compression"
      contains: "browser-image-compression"
    - path: "components/matches/match-photo-gallery.tsx"
      provides: "Photo gallery display"
      contains: "loading=\"lazy\""
  key_links:
    - from: "components/matches/match-photo-uploader.tsx"
      to: "lib/db/match-photos.ts"
      via: "server action call"
      pattern: "addMatchPhoto"
    - from: "match-photo-gallery.tsx"
      to: "match-photos.ts"
      via: "getMatchPhotos"
      pattern: "photos\\.map"
---

<objective>
Implement match photo upload with client-side compression and photo gallery display.

Purpose: Enable users to upload and view match highlight photos with optimized file sizes.
Output: Photo upload component, gallery component, match photos server actions, browser-image-compression integration.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-post-match-statistics/05-RESEARCH.md

# Existing patterns
@lib/image-utils.ts
@lib/db/goals.ts
@hooks/use-player-ratings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install browser-image-compression</name>
  <files>package.json</files>
  <action>
    Install the browser-image-compression library for client-side image compression:
    
    ```bash
    npm install browser-image-compression
    ```
    
    Verify installation by checking package.json includes the dependency.
    
    This library provides:
    - Client-side image compression (no server processing needed)
    - WebWorker support for non-blocking compression
    - Configurable quality and size limits
    - Format conversion (to JPEG for consistency)
  </action>
  <verify>
    npm ls browser-image-compression succeeds
    grep "browser-image-compression" package.json shows dependency
  </verify>
  <done>
    browser-image-compression installed
    package.json updated with new dependency
  </done>
</task>

<task type="auto">
  <name>Task 2: Create match photos server actions</name>
  <files>lib/db/match-photos.ts</files>
  <action>
    Create lib/db/match-photos.ts with CRUD operations for match photos:
    
    **Type definitions:**
    ```typescript
    export interface MatchPhoto {
      id: string
      match_id: string
      url: string  // Base64 data URL
      caption?: string
      order: number
      created_at: string
    }
    
    export interface AddPhotoInput {
      matchId: string
      file: string  // Base64 data URL
      caption?: string
    }
    ```
    
    **Functions to implement:**
    
    1. `addMatchPhoto(data: AddPhotoInput): Promise<MatchPhoto>`
       - Verify user is team admin
       - Verify match exists and is COMPLETED
       - Get current max order for the match
       - Store photo as base64 in Match.photos JSON field
       - Return the created photo object
    
    2. `getMatchPhotos(matchId: string): Promise<MatchPhoto[]>`
       - Get Match record
       - Parse photos from JSON field
       - Return array sorted by order
    
    3. `deleteMatchPhoto(matchId: string, photoOrder: number): Promise<void>`
       - Verify user is team admin
       - Get match and parse photos
       - Remove photo at specified order
       - Reorder remaining photos
       - Update Match.photos JSON
    
    4. `updatePhotoCaption(matchId: string, photoOrder: number, caption: string): Promise<void>`
       - Verify user is team admin
       - Update caption for specific photo
    
    **Schema note:** This plan assumes Match.photos is a Json field storing an array:
    ```json
    [
      { "id": "cuid", "url": "data:image/jpeg;base64,...", "caption": "Goal!", "order": 1, "createdAt": "..." },
      ...
    ]
    ```
    
    However, since Plan 01 did not add this field, we need to handle it here.
    Add photos field to Match model in prisma/schema.prisma:
    ```prisma
    model Match {
      // ... existing fields ...
      photos     Json?    @map("photos")  // Array of photo objects
    }
    ```
    Run `npx prisma db push` after adding the field.
    
    **Error messages (Italian):**
    - UNAUTHORIZED: 'Devi essere autenticato'
    - NOT_ADMIN: 'Solo gli amministratori possono gestire le foto'
    - MATCH_NOT_FOUND: 'Partita non trovata'
    - MATCH_NOT_COMPLETED: 'Le foto possono essere aggiunte solo a partite completate'
    - PHOTO_NOT_FOUND: 'Foto non trovata'
    - FILE_TOO_LARGE: 'Il file Ã¨ troppo grande (max 5MB dopo compressione)'
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep -n "addMatchPhoto\|getMatchPhotos\|deleteMatchPhoto" lib/db/match-photos.ts shows all functions
    grep "photos.*Json" prisma/schema.prisma shows photos field
  </verify>
  <done>
    Match.photos Json field added to schema
    lib/db/match-photos.ts created with CRUD operations
    Photos stored as base64 in JSON field
  </done>
</task>

<task type="auto">
  <name>Task 3: Create photo upload component</name>
  <files>components/matches/match-photo-uploader.tsx, hooks/use-match-photos.ts</files>
  <action>
    Create the photo upload component with client-side compression:
    
    **1. Create hooks/use-match-photos.ts:**
    ```typescript
    export function useMatchPhotos(matchId: string) {
      const [photos, setPhotos] = useState<MatchPhoto[]>([])
      const [isLoading, setIsLoading] = useState(true)
      const [isUploading, setIsUploading] = useState(false)
      
      // Fetch photos on mount
      useEffect(() => { /* fetch photos */ }, [matchId])
      
      const uploadPhoto = useCallback(async (file: File, caption?: string) => {
        setIsUploading(true)
        try {
          // Compress image
          const compressed = await compressImage(file)
          // Convert to base64
          const base64 = await fileToBase64(compressed)
          // Upload
          const photo = await addMatchPhoto({ matchId, file: base64, caption })
          setPhotos(prev => [...prev, photo])
          toast.success('Foto caricata!')
        } catch (error) {
          toast.error(error.message)
        } finally {
          setIsUploading(false)
        }
      }, [matchId])
      
      const removePhoto = useCallback(async (photoOrder: number) => {
        // Delete and update state
      }, [matchId])
      
      return { photos, isLoading, isUploading, uploadPhoto, removePhoto, refresh }
    }
    
    async function compressImage(file: File): Promise<File> {
      const options = {
        maxSizeMB: 1,
        maxWidthOrHeight: 1920,
        useWebWorker: true,
        fileType: 'image/jpeg',
        initialQuality: 0.85,
      }
      return await imageCompression(file, options)
    }
    
    function fileToBase64(file: File): Promise<string> {
      return new Promise((resolve, reject) => {
        const reader = new FileReader()
        reader.onload = () => resolve(reader.result as string)
        reader.onerror = reject
        reader.readAsDataURL(file)
      })
    }
    ```
    
    **2. Create components/matches/match-photo-uploader.tsx:**
    ```typescript
    interface MatchPhotoUploaderProps {
      matchId: string
      onPhotoUploaded?: (photo: MatchPhoto) => void
    }
    
    export function MatchPhotoUploader({ matchId, onPhotoUploaded }: MatchPhotoUploaderProps) {
      const { uploadPhoto, isUploading } = useMatchPhotos(matchId)
      const fileInputRef = useRef<HTMLInputElement>(null)
      
      const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0]
        if (!file) return
        
        // Validate file type
        if (!file.type.startsWith('image/')) {
          toast.error('Seleziona un file immagine')
          return
        }
        
        await uploadPhoto(file)
        // Reset input
        if (fileInputRef.current) fileInputRef.current.value = ''
      }
      
      return (
        <div className="flex flex-col gap-2">
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            onChange={handleFileSelect}
            className="hidden"
          />
          <Button
            onClick={() => fileInputRef.current?.click()}
            disabled={isUploading}
            className="w-full"
          >
            {isUploading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Caricamento...
              </>
            ) : (
              <>
                <Camera className="mr-2 h-4 w-4" />
                Aggiungi Foto
              </>
            )}
          </Button>
          <p className="text-xs text-muted-foreground text-center">
            Immagini compresse automaticamente (max 1MB)
          </p>
        </div>
      )
    }
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    ls components/matches/match-photo-uploader.tsx exists
    grep "imageCompression" hooks/use-match-photos.ts shows compression usage
  </verify>
  <done>
    useMatchPhotos hook created with compression
    MatchPhotoUploader component created
    Images compressed to max 1MB before upload
  </done>
</task>

<task type="auto">
  <name>Task 4: Create photo gallery component</name>
  <files>components/matches/match-photo-gallery.tsx</files>
  <action>
    Create components/matches/match-photo-gallery.tsx for displaying match photos:
    
    **Props:**
    ```typescript
    interface MatchPhotoGalleryProps {
      matchId: string
      editable?: boolean  // Show delete buttons
      className?: string
    }
    ```
    
    **Features:**
    - Grid layout: 2 columns on mobile, 3 on tablet, 4 on desktop
    - Lazy loading: Use `loading="lazy"` on images
    - Click to view full-size (open in modal/lightbox)
    - Delete button (trash icon) overlay when editable=true
    - Empty state: "Nessuna foto" message with upload prompt
    - Loading skeletons while fetching
    
    **Implementation:**
    ```tsx
    export function MatchPhotoGallery({ matchId, editable, className }: MatchPhotoGalleryProps) {
      const { photos, isLoading, removePhoto } = useMatchPhotos(matchId)
      const [selectedPhoto, setSelectedPhoto] = useState<MatchPhoto | null>(null)
      
      if (isLoading) {
        return (
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
            {[...Array(4)].map((_, i) => (
              <Skeleton key={i} className="aspect-square rounded-lg" />
            ))}
          </div>
        )
      }
      
      if (photos.length === 0) {
        return (
          <div className="text-center py-8 text-muted-foreground">
            <ImageIcon className="mx-auto h-12 w-12 mb-2 opacity-50" />
            <p>Nessuna foto per questa partita</p>
          </div>
        )
      }
      
      return (
        <>
          <div className={cn("grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2", className)}>
            {photos.map((photo) => (
              <div key={photo.id} className="relative group aspect-square">
                <img
                  src={photo.url}
                  alt={photo.caption || 'Foto partita'}
                  loading="lazy"
                  className="w-full h-full object-cover rounded-lg cursor-pointer hover:opacity-90 transition-opacity"
                  onClick={() => setSelectedPhoto(photo)}
                />
                {editable && (
                  <button
                    onClick={() => removePhoto(photo.order)}
                    className="absolute top-1 right-1 p-1 bg-black/50 rounded-full opacity-0 group-hover:opacity-100 transition-opacity"
                  >
                    <Trash2 className="h-4 w-4 text-white" />
                  </button>
                )}
                {photo.caption && (
                  <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-xs p-1 rounded-b-lg truncate">
                    {photo.caption}
                  </div>
                )}
              </div>
            ))}
          </div>
          
          {/* Full-size modal */}
          {selectedPhoto && (
            <Dialog open onOpenChange={() => setSelectedPhoto(null)}>
              <DialogContent className="max-w-4xl">
                <img src={selectedPhoto.url} alt="" className="w-full rounded-lg" />
                {selectedPhoto.caption && (
                  <p className="text-center text-muted-foreground">{selectedPhoto.caption}</p>
                )}
              </DialogContent>
            </Dialog>
          )}
        </>
      )
    }
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    ls components/matches/match-photo-gallery.tsx exists
    grep "loading=\"lazy\"" components/matches/match-photo-gallery.tsx shows lazy loading
  </verify>
  <done>
    MatchPhotoGallery component created
    Lazy loading implemented for images
    Delete functionality for editable mode
    Full-size modal view implemented
  </done>
</task>

<task type="auto">
  <name>Task 5: Add translations and integrate into match detail</name>
  <files>messages/it.json, messages/en.json, components/matches/completed-match-detail.tsx</files>
  <action>
    Add photo-related translations and integrate photo gallery into completed match detail:
    
    **Add to messages/it.json:**
    ```json
    "photos": {
      "title": "Foto Partita",
      "add": "Aggiungi Foto",
      "uploading": "Caricamento...",
      "no_photos": "Nessuna foto per questa partita",
      "delete_confirm": "Eliminare questa foto?",
      "caption_placeholder": "Aggiungi didascalia...",
      "compression_note": "Immagini compresse automaticamente (max 1MB)"
    }
    ```
    
    **Add to messages/en.json:**
    ```json
    "photos": {
      "title": "Match Photos",
      "add": "Add Photo",
      "uploading": "Uploading...",
      "no_photos": "No photos for this match",
      "delete_confirm": "Delete this photo?",
      "caption_placeholder": "Add caption...",
      "compression_note": "Images automatically compressed (max 1MB)"
    }
    ```
    
    **Integrate into components/matches/completed-match-detail.tsx:**
    - Add a "Foto Partita" section after the ratings section
    - Show MatchPhotoUploader for team admins
    - Show MatchPhotoGallery with editable=true for admins, false for members
    
    ```tsx
    // Inside CompletedMatchDetail
    const isTeamAdmin = useIsTeamAdmin(teamId)  // or from props
    
    // In the JSX, after ratings section:
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Camera className="h-5 w-5" />
          Foto Partita
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {isTeamAdmin && <MatchPhotoUploader matchId={matchId} />}
        <MatchPhotoGallery matchId={matchId} editable={isTeamAdmin} />
      </CardContent>
    </Card>
    ```
  </action>
  <verify>
    npx tsc --noEmit succeeds
    grep "photos" messages/it.json shows photo translations
    grep "MatchPhotoUploader\|MatchPhotoGallery" components/matches/completed-match-detail.tsx shows integration
  </verify>
  <done>
    Photo translations added to it.json and en.json
    Photo gallery integrated into completed match detail
    Admin users can upload and delete photos
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` to verify TypeScript compilation
2. Verify browser-image-compression is installed
3. Verify Match.photos field exists in schema
4. Verify compression works (test with a large image)
5. Verify lazy loading works in gallery
6. Verify photos persist in database
</verification>

<success_criteria>
- browser-image-compression installed and working
- Match.photos Json field stores photo array
- Photos compressed to max 1MB before upload
- MatchPhotoUploader allows image selection and upload
- MatchPhotoGallery displays photos with lazy loading
- Admin can delete photos from gallery
- Photos integrated into completed match detail view
</success_criteria>

<output>
After completion, create `.planning/phases/05-post-match-statistics/05-03-SUMMARY.md`
</output>
