---
phase: 03-match-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260215000002_matches_rsvps_formations.sql
  - lib/db/schema.ts
  - lib/db/index.ts
  - types/database.ts
autonomous: true

must_haves:
  truths:
    - "Database can store matches with date, time, location, and mode"
    - "Database can track player RSVPs (IN/OUT/Maybe) per match"
    - "Database can store formations with player positions"
    - "RLS policies enforce team-based access to match data"
    - "IndexedDB schema supports offline match data caching"
  artifacts:
    - path: "supabase/migrations/20260215000002_matches_rsvps_formations.sql"
      provides: "PostgreSQL tables for matches, match_players (RSVP), formations, formation_positions"
      min_lines: 300
    - path: "lib/db/schema.ts"
      provides: "TypeScript interfaces for Match, MatchPlayer, Formation, FormationPosition, RSVPStatus"
      exports: ["Match", "MatchPlayer", "Formation", "FormationPosition", "RSVPStatus"]
    - path: "types/database.ts"
      provides: "Supabase-generated types for match-related tables"
      exports: ["Database"]
  key_links:
    - from: "matches table"
      to: "teams table"
      via: "team_id foreign key"
      pattern: "REFERENCES teams"
    - from: "match_players table"
      to: "matches table"
      via: "match_id foreign key"
      pattern: "REFERENCES matches"
    - from: "formations table"
      to: "matches table"
      via: "match_id foreign key"
      pattern: "REFERENCES matches"
---

<objective>
Create database schema for match management with matches, RSVPs, and formations support.

Purpose: Provide the data foundation for scheduling matches, tracking player availability, and building tactical formations.

Output: Database migration with 4 new tables (matches, match_players, formations, formation_positions), RLS policies, IndexedDB v3 schema, TypeScript types.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-team-management/02-01-SUMMARY.md
@supabase/migrations/20260215000001_teams_players_invites.sql
@lib/db/schema.ts
@lib/db/index.ts
@types/database.ts

## Phase Context
Phase 3 implements match scheduling, RSVPs (IN/OUT/Maybe), and formation builder. This plan establishes the database foundation that all subsequent Phase 3 plans depend on.

## Requirements Covered
- MATCH-01: Match creation with date, time, location
- MATCH-02: Match mode selection (5vs5 or 8vs8)
- MATCH-03: Formation module selection based on match mode
- MATCH-04: Player RSVP assignment
- MATCH-05: Availability count tracking
- MATCH-06: Formation builder data storage

## Patterns from Phase 2
- Junction tables for many-to-many relationships
- RLS policies using SECURITY DEFINER helper functions
- sync_status field on all entities for offline-first
- IndexedDB schema versioning (currently v2)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database migration for match management</name>
  <files>
    - supabase/migrations/20260215000002_matches_rsvps_formations.sql
  </files>
  <action>
Create a new PostgreSQL migration file at supabase/migrations/20260215000002_matches_rsvps_formations.sql with:

1. **matches table** - The core match entity:
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - team_id: UUID NOT NULL REFERENCES teams(id) ON DELETE CASCADE
   - scheduled_at: TIMESTAMPTZ NOT NULL (match date and time combined)
   - location: VARCHAR(255) - venue name or address
   - mode: VARCHAR(10) CHECK mode IN ('5vs5', '8vs8') - match format
   - status: VARCHAR(20) CHECK status IN ('scheduled', 'in_progress', 'completed', 'cancelled')
   - home_score: INTEGER, away_score: INTEGER - only populated when status in ('completed', 'in_progress')
   - notes: TEXT - optional match notes
   - created_by: UUID REFERENCES auth.users(id)
   - created_at, updated_at: TIMESTAMPTZ DEFAULT NOW()
   - sync_status: VARCHAR(20) DEFAULT 'synced'

2. **match_players table** - RSVP tracking (junction between matches and players):
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - match_id: UUID NOT NULL REFERENCES matches(id) ON DELETE CASCADE
   - player_id: UUID NOT NULL REFERENCES players(id) ON DELETE CASCADE
   - rsvp_status: VARCHAR(10) CHECK IN ('in', 'out', 'maybe') - player's response
   - rsvp_at: TIMESTAMPTZ - when they responded
   - position_on_pitch: VARCHAR(20) - assigned position (nullable, set by formation builder)
   - sync_status: VARCHAR(20) DEFAULT 'synced'
   - UNIQUE(match_id, player_id) - one RSVP per player per match

3. **formations table** - Formation templates per match:
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - match_id: UUID NOT NULL UNIQUE REFERENCES matches(id) ON DELETE CASCADE (one formation per match)
   - team_formation: JSONB - stores formation structure like {"formation": "4-3-3", "positions": [...]}
   - created_at, updated_at: TIMESTAMPTZ DEFAULT NOW()

4. **formation_positions table** - Player assignments to positions:
   - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
   - formation_id: UUID NOT NULL REFERENCES formations(id) ON DELETE CASCADE
   - player_id: UUID REFERENCES players(id) ON DELETE SET NULL (player can be unassigned)
   - position_x: INTEGER (grid column 0-9 for horizontal positioning on pitch)
   - position_y: INTEGER (grid row 0-6 for vertical positioning on pitch)
   - position_label: VARCHAR(20) - human-readable label (e.g., "GK", "ST", "RW")
   - is_substitute: BOOLEAN DEFAULT FALSE - distinguishes bench from field
   - UNIQUE(formation_id, position_x, position_y) - one player per grid cell

5. **RLS Policies** (follow Phase 2 patterns):
   - matches: SELECT for team members, INSERT/UPDATE/DELETE for team admins
   - match_players: SELECT for team members, INSERT/UPDATE for self (players can RSVP for themselves), admins can modify any
   - formations: SELECT for team members, UPDATE for team admins
   - formation_positions: SELECT for team members, INSERT/UPDATE/DELETE for team admins

6. **Helper Functions**:
   - is_match_admin(match_uuid UUID) - checks if user is admin of the team that owns the match
   - is_match_participant(match_uuid UUID) - checks if user is a team member for this match

7. **Indexes**:
   - idx_matches_team_id, idx_matches_scheduled_at, idx_matches_status
   - idx_match_players_match_id, idx_match_players_player_id, idx_match_players_rsvp_status
   - idx_formations_match_id
   - idx_formation_positions_formation_id

8. **Triggers**: auto-update updated_at on matches and formations tables

Follow existing migration patterns from 20260215000001_teams_players_invites.sql for consistency.
  </action>
  <verify>
Verify SQL syntax is valid by checking:
- All FOREIGN KEY constraints reference existing tables
- CHECK constraints have valid enum values
- RLS policies use proper syntax with USING and WITH CHECK clauses
- Indexes follow naming convention idx_tablename_columnname
  </verify>
  <done>
Migration file exists at supabase/migrations/20260215000002_matches_rsvps_formations.sql with 4 new tables, RLS policies, indexes, triggers, and helper functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend IndexedDB schema for offline match support</name>
  <files>
    - lib/db/schema.ts
    - lib/db/index.ts
  </files>
  <action>
Extend IndexedDB schema to support match-related entities:

**In lib/db/schema.ts:**

1. Add new TypeScript interfaces:
   ```typescript
   export type RSVPStatus = 'in' | 'out' | 'maybe';
   export type MatchStatus = 'scheduled' | 'in_progress' | 'completed' | 'cancelled';
   export type MatchMode = '5vs5' | '8vs8';
   
   export interface Match {
     id: string;
     team_id: string;
     scheduled_at: string; // ISO datetime
     location?: string;
     mode: MatchMode;
     status: MatchStatus;
     home_score?: number;
     away_score?: number;
     notes?: string;
     created_by: string;
     created_at: string;
     updated_at: string;
     sync_status: SyncStatus;
   }
   
   export interface MatchPlayer {
     id: string;
     match_id: string;
     player_id: string;
     rsvp_status: RSVPStatus;
     rsvp_at: string;
     position_on_pitch?: string;
     sync_status: SyncStatus;
   }
   
   export interface Formation {
     id: string;
     match_id: string;
     team_formation: {
       formation: string;
       positions: Array<{
         x: number;
         y: number;
         label: string;
       }>;
     };
     created_at: string;
     updated_at: string;
   }
   
   export interface FormationPosition {
     id: string;
     formation_id: string;
     player_id?: string;
     position_x: number;
     position_y: number;
     position_label: string;
     is_substitute: boolean;
   }
   ```

2. Update OfflineTable type:
   ```typescript
   export type OfflineTable = 'teams' | 'players' | 'matches' | 'match_players' | 'formations' | 'formation_positions' | 'team_members' | 'player_teams' | 'team_invites';
   ```

3. Add to CalcettoDB interface:
   ```typescript
   match_players: {
     key: string;
     value: MatchPlayer;
     indexes: {
       'by-match-id': string;
       'by-player-id': string;
       'by-sync-status': string;
     };
   };
   formations: {
     key: string;
     value: Formation;
     indexes: {
       'by-match-id': string;
     };
   };
   formation_positions: {
     key: string;
     value: FormationPosition;
     indexes: {
       'by-formation-id': string;
     };
   };
   ```

**In lib/db/index.ts:**

1. Increment DB_VERSION from 2 to 3
2. Add upgrade logic for v2 -> v3:
   ```typescript
   // v3: Add match management stores
   if (oldVersion < 3) {
     // Add match_players store
     if (!db.objectStoreNames.contains('match_players')) {
       const matchPlayersStore = db.createObjectStore('match_players', { keyPath: 'id' });
       matchPlayersStore.createIndex('by-match-id', 'match_id');
       matchPlayersStore.createIndex('by-player-id', 'player_id');
       matchPlayersStore.createIndex('by-sync-status', 'sync_status');
     }
     
     // Add formations store
     if (!db.objectStoreNames.contains('formations')) {
       const formationsStore = db.createObjectStore('formations', { keyPath: 'id' });
       formationsStore.createIndex('by-match-id', 'match_id');
     }
     
     // Add formation_positions store
     if (!db.objectStoreNames.contains('formation_positions')) {
       const positionsStore = db.createObjectStore('formation_positions', { keyPath: 'id' });
       positionsStore.createIndex('by-formation-id', 'formation_id');
     }
     
     console.log('[IndexedDB] Upgraded to v3 - added match management stores');
   }
   ```

Preserve existing stores and indexes. Only add new ones.
  </action>
  <verify>
Run TypeScript check: npx tsc --noEmit lib/db/schema.ts lib/db/index.ts
Verify no type errors, all interfaces properly exported, DB_VERSION is 3.
  </verify>
  <done>
lib/db/schema.ts has Match, MatchPlayer, Formation, FormationPosition interfaces. lib/db/index.ts has DB_VERSION=3 with v3 upgrade logic creating match_players, formations, and formation_positions stores.
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate Supabase database types</name>
  <files>
    - types/database.ts
  </files>
  <action>
Update types/database.ts to include match-related tables:

1. Add matches table to Database['public']['Tables']:
   - Row: id, team_id, scheduled_at, location?, mode, status, home_score?, away_score?, notes?, created_by, created_at, updated_at, sync_status?
   - Insert: Same fields with optional created_at/updated_at/sync_status
   - Update: All fields optional
   - Relationships: team_id -> teams, created_by -> users

2. Add match_players table:
   - Row: id, match_id, player_id, rsvp_status, rsvp_at, position_on_pitch?, sync_status?
   - Relationships: match_id -> matches, player_id -> players

3. Add formations table:
   - Row: id, match_id, team_formation (JSONB), created_at, updated_at
   - Relationships: match_id -> matches

4. Add formation_positions table:
   - Row: id, formation_id, player_id?, position_x, position_y, position_label, is_substitute
   - Relationships: formation_id -> formations, player_id -> players

5. Add helper functions to Database['public']['Functions']:
   - is_match_admin: Args { match_uuid: string }, Returns boolean
   - is_match_participant: Args { match_uuid: string }, Returns boolean

6. Add new table types to Helper types section:
   - export type Match = Tables<'matches'>;
   - export type MatchPlayer = Tables<'match_players'>;
   - export type Formation = Tables<'formations'>;
   - export type FormationPosition = Tables<'formation_positions'>;

Follow existing patterns in the file for consistency. The matches store already exists from Phase 1 (was added as placeholder), but needs to be updated with the new schema fields.
  </action>
  <verify>
TypeScript compiles without errors:
npx tsc --noEmit types/database.ts

All new tables have Row, Insert, Update types.
All foreign key relationships are declared.
New table types are exported at bottom of file.
  </verify>
  <done>
types/database.ts has TypeScript types for matches, match_players, formations, formation_positions tables with all fields, relationships, and helper function signatures exported.
  </done>
</task>

</tasks>

<verification>
Before proceeding to Wave 2, verify:
1. All 4 SQL tables created with proper constraints and indexes
2. RLS policies prevent unauthorized access to match data
3. IndexedDB v3 schema supports offline match caching
4. TypeScript types are complete and compile
5. Migration file follows naming convention and is ready to apply
</verification>

<success_criteria>
- Database migration creates matches, match_players, formations, formation_positions tables
- RLS policies enforce team-based access control
- IndexedDB schema v3 supports offline match data
- TypeScript types exported for all match entities
</success_criteria>

<output>
After completion, create `.planning/phases/03-match-management/03-01-SUMMARY.md`
</output>
