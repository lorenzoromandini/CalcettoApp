---
phase: 03-match-management
gap_plan: 03-07
type: gap_closure
wave: 7
depends_on: []
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All database operations use Prisma client instead of Supabase"
    - "Existing Supabase code is removed or deprecated"
    - "TypeScript types are compatible with Prisma schema"
    - "All CRUD operations work with actual database persistence"
  artifacts:
    - path: "lib/db/matches.ts"
      provides: "Match CRUD with Prisma client"
    - path: "lib/db/rsvps.ts"
      provides: "RSVP operations with Prisma client"
    - path: "lib/db/formations.ts"
      provides: "Formation CRUD with Prisma client"
    - path: "lib/db/players.ts"
      provides: "Player operations with Prisma client"
    - path: "lib/db/teams.ts"
      provides: "Team operations with Prisma client"
    - path: "lib/db/index.ts"
      provides: "Prisma client singleton export"
  removed:
    - path: "lib/supabase/client.ts"
      reason: "No longer needed with Prisma"
    - path: "lib/supabase/server.ts"
      reason: "No longer needed with Prisma"
---

<objective>
Refactor database layer from Supabase to Prisma to fix data persistence issues.

Purpose: The project uses Prisma + NextAuth but database operations were implemented with Supabase client, causing a mismatch where data doesn't actually persist.

Output: All database operations migrated to Prisma client with working persistence.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-match-management/03-VERIFICATION.md
@.planning/phases/03-match-management/03-01-SUMMARY.md

## Current State
- UI is fully implemented and working
- Database operations use Supabase client (`@/lib/supabase/client`)
- Project actually uses Prisma + NextAuth
- Stub Supabase client returns errors for all operations

## Prisma Schema
The schema already exists at `prisma/schema.prisma` with models for:
- Match, MatchPlayer, Formation, FormationPosition
- Team, TeamMember, Player, PlayerTeam, TeamInvite
- User (via NextAuth)

## Files to Refactor
1. `lib/db/matches.ts` - Match CRUD
2. `lib/db/rsvps.ts` - RSVP operations
3. `lib/db/formations.ts` - Formation CRUD
4. `lib/db/players.ts` - Player operations
5. `lib/db/teams.ts` - Team operations
6. `lib/db/index.ts` - Create Prisma client export
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prisma client singleton</name>
  <files>
    - lib/db/index.ts
  </files>
  <action>
Create Prisma client singleton for database operations:

**lib/db/index.ts:**

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

export default prisma;
```

This follows the Next.js pattern for Prisma client singleton to prevent multiple instances in development.
  </action>
  <verify>
TypeScript compiles and Prisma client can be imported.
  </verify>
  <done>
Prisma client singleton created at lib/db/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor matches.ts to use Prisma</name>
  <files>
    - lib/db/matches.ts
  </files>
  <action>
Replace Supabase calls with Prisma operations in lib/db/matches.ts:

**Key changes:**
- Replace `createClient()` import with `prisma` from `./index`
- Convert `createMatch()` to use `prisma.match.create()`
- Convert `getTeamMatches()` to use `prisma.match.findMany()`
- Convert `getMatch()` to use `prisma.match.findUnique()`
- Convert `updateMatch()` to use `prisma.match.update()`
- Convert `cancelMatch()` to use `prisma.match.update()` with status change
- Convert `uncancelMatch()` to use `prisma.match.update()` with status change
- Remove all Supabase-specific code (subscriptions, realtime)
- Keep the same function signatures for UI compatibility

**Example conversion:**
```typescript
// Before (Supabase):
const { data, error } = await supabase
  .from('matches')
  .insert({ team_id, scheduled_at, location, mode, notes })
  .single();

// After (Prisma):
const match = await prisma.match.create({
  data: {
    teamId,
    scheduledAt: new Date(scheduledAt),
    location,
    mode,
    notes,
    status: 'scheduled',
  },
});
```

Note: Update field names to match Prisma schema (snake_case → camelCase).
  </action>
  <verify>
TypeScript compiles without errors. Function signatures remain compatible.
  </verify>
  <done>
Matches database layer refactored to Prisma.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor rsvps.ts to use Prisma</name>
  <files>
    - lib/db/rsvps.ts
  </files>
  <action>
Replace Supabase calls with Prisma operations in lib/db/rsvps.ts:

**Key changes:**
- Replace Supabase client with Prisma client
- Convert `updateRSVP()` to use `prisma.matchPlayer.upsert()`
- Convert `getMatchRSVPs()` to use `prisma.matchPlayer.findMany()` with player include
- Convert `getRSVPCounts()` to use aggregation queries
- Convert `getMyRSVP()` to use `prisma.matchPlayer.findFirst()`
- Remove Supabase realtime subscription code (will handle via SWR/React Query)
- Keep the same function signatures for UI compatibility

**Example conversion:**
```typescript
// Before (Supabase):
const { data, error } = await supabase
  .from('match_players')
  .upsert({ match_id, player_id, rsvp_status });

// After (Prisma):
const rsvp = await prisma.matchPlayer.upsert({
  where: {
    matchId_playerId: { matchId, playerId }
  },
  update: { rsvpStatus },
  create: {
    matchId,
    playerId,
    rsvpStatus,
  },
});
```
  </action>
  <verify>
TypeScript compiles without errors. Function signatures remain compatible.
  </verify>
  <done>
RSVP database layer refactored to Prisma.
  </done>
</task>

<task type="auto">
  <name>Task 4: Refactor formations.ts to use Prisma</name>
  <files>
    - lib/db/formations.ts
  </files>
  <action>
Replace Supabase calls with Prisma operations in lib/db/formations.ts:

**Key changes:**
- Replace Supabase client with Prisma client
- Convert `getFormation()` to use `prisma.formation.findUnique()` with positions include
- Convert `saveFormation()` to use `prisma.formation.upsert()` with nested positions
- Convert `deleteFormation()` to use `prisma.formation.delete()`
- Handle nested writes for formation positions
- Keep the same function signatures for UI compatibility

**Example conversion:**
```typescript
// Before (Supabase):
const { data, error } = await supabase
  .from('formations')
  .upsert({ match_id, module, players_count });

// After (Prisma):
const formation = await prisma.formation.upsert({
  where: { matchId },
  update: {
    module,
    playersCount,
    positions: {
      deleteMany: {},
      create: positions,
    },
  },
  create: {
    matchId,
    module,
    playersCount,
    positions: { create: positions },
  },
});
```
  </action>
  <verify>
TypeScript compiles without errors. Function signatures remain compatible.
  </verify>
  <done>
Formation database layer refactored to Prisma.
  </done>
</task>

<task type="auto">
  <name>Task 5: Refactor players.ts and teams.ts to use Prisma</name>
  <files>
    - lib/db/players.ts
    - lib/db/teams.ts
  </files>
  <action>
Replace Supabase calls with Prisma operations in players.ts and teams.ts:

**For players.ts:**
- Replace Supabase with Prisma for player CRUD
- Handle player-team relationships via Prisma
- Handle avatar uploads (may need to keep Supabase Storage or switch to another solution)

**For teams.ts:**
- Replace Supabase with Prisma for team CRUD
- Handle team memberships and roles
- Handle invite operations

**Note:** Avatar storage is currently using Supabase Storage. Options:
1. Keep Supabase Storage just for avatars (hybrid approach)
2. Switch to local file storage or another provider
3. Use base64 in database (not recommended for production)

For now, document that avatars still use Supabase Storage, or implement a simple placeholder solution.
  </action>
  <verify>
TypeScript compiles without errors. All function signatures remain compatible.
  </verify>
  <done>
Player and team database layers refactored to Prisma.
  </done>
</task>

<task type="auto">
  <name>Task 6: Remove Supabase stubs and clean up</name>
  <files>
    - lib/supabase/client.ts
    - lib/supabase/server.ts
  </files>
  <action>
Remove Supabase stub files:

1. Delete `lib/supabase/client.ts`
2. Delete `lib/supabase/server.ts`
3. Remove `lib/supabase/` directory if empty

Update any remaining imports:
- Search for `@/lib/supabase/client` imports
- Replace with `@/lib/db` where needed
- Remove unused Supabase-related code

Run TypeScript check:
```bash
npx tsc --noEmit
```

Fix any remaining type errors.
  </action>
  <verify>
No TypeScript errors. No remaining Supabase client imports.
  </verify>
  <done>
Supabase stubs removed, codebase cleaned up.
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 7: Verify data persistence works end-to-end</name>
  <what-built>
Complete Prisma database layer refactor:
- Prisma client singleton for database access
- All database operations converted from Supabase to Prisma
- Match CRUD with actual persistence
- RSVP operations with actual persistence
- Formation operations with actual persistence
- Player and team operations with actual persistence
- Removed Supabase stub files
  </what-built>
  <how-to-verify>
Please verify the following scenarios:

**Scenario 1: Match Creation**
1. Navigate to a team → Matches tab
2. Click "Crea partita"
3. Fill in date/time, location, select mode
4. Submit
5. **Verify:** Match appears in list and persists after refresh

**Scenario 2: RSVP Persistence**
1. Open a match detail
2. Click "Ci sono!" RSVP button
3. **Verify:** Button shows selected state
4. Refresh page
5. **Verify:** RSVP status persists

**Scenario 3: Formation Save**
1. From match detail, click "Crea formazione"
2. Select formation preset
3. Position some players
4. Click "Salva formazione"
5. **Verify:** Formation preview appears on match detail
6. Refresh page
7. **Verify:** Formation persists

**Scenario 4: Database Verification**
1. Check Prisma Studio or database directly:
   ```bash
   npx prisma studio
   ```
2. Verify records exist in:
   - `Match` table
   - `MatchPlayer` table (RSVPs)
   - `Formation` and `FormationPosition` tables

**Expected Results:**
- All data persists correctly
- No Supabase-related errors in console
- TypeScript compiles without errors
  </how-to-verify>
  <resume-signal>Type "approved" if all scenarios pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
Before marking complete, verify:
1. No Supabase client imports remain
2. All database operations use Prisma
3. TypeScript compiles without errors
4. Data actually persists to database
5. All existing UI functionality still works
</verification>

<success_criteria>
- Prisma client singleton exported from lib/db/index.ts
- All database operations use Prisma instead of Supabase
- Supabase stub files removed
- Data persists correctly to database
- TypeScript compiles without errors
- All UI functionality works with new data layer
</success_criteria>

<output>
After completion, create `.planning/phases/03-match-management/03-07-SUMMARY.md`
</output>
