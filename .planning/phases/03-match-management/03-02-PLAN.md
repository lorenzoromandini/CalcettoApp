---
phase: 03-match-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - lib/db/matches.ts
  - lib/validations/match.ts
  - hooks/use-matches.ts
  - components/matches/match-form.tsx
  - components/matches/match-card.tsx
  - app/[locale]/teams/[teamId]/matches/page.tsx
  - app/[locale]/teams/[teamId]/matches/create/page.tsx
  - app/[locale]/teams/[teamId]/matches/[matchId]/page.tsx
  - messages/it.json
  - messages/en.json
autonomous: true

must_haves:
  truths:
    - "Team admin can create a match with date, time, location, and mode (5vs5 or 8vs8)"
    - "Match appears in team's match list with all details visible"
    - "User can edit match details before match starts"
    - "User can cancel/uncancel a match"
    - "Match list shows upcoming and past matches separately"
  artifacts:
    - path: "lib/db/matches.ts"
      provides: "CRUD operations for matches with offline queue integration"
      exports: ["createMatch", "getTeamMatches", "getMatch", "updateMatch", "cancelMatch", "getUpcomingMatches", "getPastMatches"]
    - path: "hooks/use-matches.ts"
      provides: "React hooks for match data and mutations"
      exports: ["useMatches", "useMatch", "useCreateMatch", "useUpdateMatch", "useCancelMatch"]
    - path: "app/[locale]/teams/[teamId]/matches/page.tsx"
      provides: "Match list page with upcoming/past tabs"
    - path: "app/[locale]/teams/[teamId]/matches/create/page.tsx"
      provides: "Match creation form"
    - path: "components/matches/match-form.tsx"
      provides: "Reusable match form component with validation"
    - path: "components/matches/match-card.tsx"
      provides: "Match list item component with status badge"
  key_links:
    - from: "hooks/use-matches.ts"
      to: "lib/db/matches.ts"
      via: "import and call"
      pattern: "import.*from '@/lib/db/matches'"
    - from: "match-form.tsx"
      to: "lib/validations/match.ts"
      via: "zod schema validation"
      pattern: "zodResolver.*matchSchema"
    - from: "app/[locale]/teams/[teamId]/matches/page.tsx"
      to: "hooks/use-matches.ts"
      via: "useMatches hook"
      pattern: "const { matches } = useMatches"
---

<objective>
Implement match CRUD operations: create, list, edit, cancel matches with full UI.

Purpose: Enable teams to schedule matches and manage their match calendar.

Output: Complete match management UI with forms, lists, cards, and all database operations supporting offline-first sync.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-match-management/03-01-SUMMARY.md
@lib/db/teams.ts
@lib/db/schema.ts
@lib/validations/team.ts
@hooks/use-teams.ts
@components/teams/team-form.tsx
@components/teams/team-card.tsx

## Existing Patterns (from Phase 2)
- useTeams hook pattern: fetch data, loading states, error handling, refetch
- Form validation: react-hook-form + zod with Italian error messages
- Database operations: lib/db/*.ts with offline queue integration
- Card components: TeamCard shows key info with badges
- Page structure: /teams, /teams/create, /teams/[teamId]

## Requirements Covered
- MATCH-01: Create match with date, time, location
- MATCH-02: Select match mode (5vs5 or 8vs8)
- MATCH-07: View match list with upcoming and past matches
- MATCH-08: Edit match details before start
- MATCH-09: Cancel match

## Mobile-First Requirements
- Touch targets 44px minimum
- Date/time picker native mobile controls
- Large buttons for actions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create match validation schemas and database operations</name>
  <files>
    - lib/validations/match.ts
    - lib/db/matches.ts
  </files>
  <action>
Create match validation and database layers following Phase 2 patterns:

**lib/validations/match.ts:**
```typescript
import { z } from 'zod';

export const matchModeSchema = z.enum(['5vs5', '8vs8']);

export const createMatchSchema = z.object({
  scheduled_at: z.string().datetime({ message: 'Data e ora non valide' }),
  location: z.string().min(2, 'Inserisci una location').max(255, 'Location troppo lunga').optional(),
  mode: matchModeSchema,
  notes: z.string().max(1000, 'Note troppo lunghe').optional(),
});

export const updateMatchSchema = createMatchSchema.partial();

export type CreateMatchInput = z.infer<typeof createMatchSchema>;
export type UpdateMatchInput = z.infer<typeof updateMatchSchema>;
```

**lib/db/matches.ts:**
Create CRUD operations following the pattern from lib/db/teams.ts:

1. **createMatch(data: CreateMatchInput, teamId: string, userId: string): Promise<string>**
   - Insert into matches table
   - Set created_by = userId, team_id = teamId
   - Set status = 'scheduled'
   - Return the created match id
   - Queue offline action if offline

2. **getTeamMatches(teamId: string): Promise<Match[]>**
   - Query matches where team_id = teamId
   - Order by scheduled_at DESC
   - Return array of Match objects
   - Fall back to IndexedDB if offline

3. **getMatch(matchId: string): Promise<Match | null>**
   - Get single match by id
   - Return null if not found
   - Fall back to IndexedDB if offline

4. **getUpcomingMatches(teamId: string): Promise<Match[]>**
   - Get matches where scheduled_at >= NOW() AND status = 'scheduled'
   - Order by scheduled_at ASC (soonest first)

5. **getPastMatches(teamId: string): Promise<Match[]>**
   - Get matches where scheduled_at < NOW() OR status IN ('completed', 'cancelled')
   - Order by scheduled_at DESC (most recent first)

6. **updateMatch(matchId: string, data: UpdateMatchInput): Promise<void>**
   - Update match fields
   - Can only update if status = 'scheduled' (not started/cancelled/completed)
   - Queue offline action if offline

7. **cancelMatch(matchId: string): Promise<void>**
   - Set status = 'cancelled'
   - Can only cancel if status = 'scheduled'
   - Queue offline action if offline

8. **uncancelMatch(matchId: string): Promise<void>**
   - Set status = 'scheduled' (for undoing cancellation)

Use the same offline queue pattern from lib/db/teams.ts with queueOfflineAction.
  </action>
  <verify>
TypeScript compiles without errors:
npx tsc --noEmit lib/validations/match.ts lib/db/matches.ts

All functions exported and follow naming conventions.
  </verify>
  <done>
lib/validations/match.ts exports createMatchSchema and types. lib/db/matches.ts exports all CRUD functions with offline queue integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create match React hooks</name>
  <files>
    - hooks/use-matches.ts
  </files>
  <action>
Create hooks/use-matches.ts following the use-teams.ts pattern:

**useMatches(teamId: string):** Returns { matches, upcomingMatches, pastMatches, isLoading, error, refetch }
- Fetch all matches for team
- Split into upcoming and past arrays
- Loading and error states
- refetch function

**useMatch(matchId: string | null):** Returns { match, isLoading, error, refetch }
- Get single match details
- Null-safe for when matchId is null

**useCreateMatch():** Returns { createMatch, isPending, error }
- Async function accepting CreateMatchInput + teamId
- Returns created match id
- Loading and error states

**useUpdateMatch():** Returns { updateMatch, isPending, error }
- Async function accepting matchId + UpdateMatchInput
- Loading and error states

**useCancelMatch():** Returns { cancelMatch, uncancelMatch, isPending, error }
- Two functions: cancel and uncancel
- Loading and error states shared

Follow the exact pattern from hooks/use-teams.ts for:
- useState initialization
- useCallback for async functions
- useEffect for data fetching
- Error handling with instanceof Error
- Loading state management

Import from lib/db/matches for the actual database operations.
  </action>
  <verify>
TypeScript check passes:
npx tsc --noEmit hooks/use-matches.ts

All hooks follow the use-teams.ts pattern with proper TypeScript types.
  </verify>
  <done>
hooks/use-matches.ts exports useMatches, useMatch, useCreateMatch, useUpdateMatch, useCancelMatch hooks with proper loading/error states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create match form and card components</name>
  <files>
    - components/matches/match-form.tsx
    - components/matches/match-card.tsx
  </files>
  <action>
Create reusable match UI components:

**components/matches/match-form.tsx:**
Similar to components/teams/team-form.tsx but for matches:

```typescript
interface MatchFormProps {
  teamId: string;
  initialData?: Partial<CreateMatchInput>;
  onSuccess?: () => void;
  submitLabel?: string;
}

export function MatchForm({ teamId, initialData, onSuccess, submitLabel = 'Crea partita' }: MatchFormProps)
```

Form fields (all with mobile-optimized touch targets):
1. Date & Time picker (datetime-local input for native mobile picker)
   - Label: "Data e ora"
   - Required validation
   - Min: today (can't schedule in past)

2. Location input
   - Label: "Location"
   - Placeholder: "Campo sportivo, indirizzo..."
   - Optional field
   - Text input with h-12 (48px) height

3. Match Mode selector (radio buttons or select)
   - Label: "Modalità"
   - Options: 5vs5, 8vs8
   - Default: 5vs5
   - Large touch targets (min 44px)

4. Notes textarea
   - Label: "Note (opzionale)"
   - Optional
   - Max 1000 chars
   - Min-h-[120px]

Use react-hook-form with zodResolver(createMatchSchema).
Validation errors in Italian.
Submit button with loading state (Spinner when isPending).

**components/matches/match-card.tsx:**
Similar to components/teams/team-card.tsx:

```typescript
interface MatchCardProps {
  match: Match;
  teamId: string;
  onClick?: () => void;
}

export function MatchCard({ match, teamId, onClick }: MatchCardProps)
```

Display:
- Date and time formatted (Italian locale: "15 feb, 20:30")
- Location (if set)
- Mode badge (5vs5 or 8vs8)
- Status badge with color:
  - scheduled: blue/primary
  - in_progress: green
  - completed: gray
  - cancelled: red
- Chevron right icon for navigation

Styling:
- Card with hover shadow
- Min-h-[72px] for large touch target
- Full width with padding

Add translations to messages/it.json and messages/en.json under new "matches" key with all form labels, placeholders, and validation messages.
  </action>
  <verify>
Components render without errors in TypeScript:
npx tsc --noEmit components/matches/match-form.tsx components/matches/match-card.tsx

Form has all required fields with validation.
Card displays all match info with proper status badges.
  </verify>
  <done>
components/matches/match-form.tsx creates matches with validation. components/matches/match-card.tsx displays match info with status badges. Translations added to messages files.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create match list and detail pages</name>
  <files>
    - app/[locale]/teams/[teamId]/matches/page.tsx
    - app/[locale]/teams/[teamId]/matches/create/page.tsx
    - app/[locale]/teams/[teamId]/matches/[matchId]/page.tsx
  </files>
  <action>
Create match management pages:

**app/[locale]/teams/[teamId]/matches/page.tsx:**
Match list page with tabs for upcoming/past:

```typescript
export default function MatchesPage({ params }: { params: { locale: string; teamId: string } })
```

Layout:
- Page header: "Partite" with back button to team
- Tabs: "Prossime" / "Passate" (Upcoming / Past)
- "Crea partita" button (admin only) linking to /teams/[teamId]/matches/create

Content:
- Upcoming tab: Show upcomingMatches from useMatches
- Past tab: Show pastMatches from useMatches
- Use MatchCard component for each match
- Link to match detail: /teams/[teamId]/matches/[matchId]

Empty states:
- "Nessuna partita programmata" with icon for empty upcoming
- "Nessuna partita passata" for empty past

Loading: Skeleton cards (3-4 skeleton items)

**app/[locale]/teams/[teamId]/matches/create/page.tsx:**
Create match page:

```typescript
export default function CreateMatchPage({ params }: { params: { locale: string; teamId: string } })
```

- Check user is team admin (use admin check from team hooks)
- Show MatchForm component
- On success: redirect to /teams/[teamId]/matches
- Back button to matches list

**app/[locale]/teams/[teamId]/matches/[matchId]/page.tsx:**
Match detail page:

```typescript
export default function MatchDetailPage({ params }: { params: { locale: string; teamId: string; matchId: string } })
```

Display:
- Match date/time (large, prominent)
- Location (if set)
- Mode badge
- Status badge
- Notes (if set)
- Action buttons (admin only):
  - "Modifica" (if status = scheduled) → opens edit modal/page
  - "Annulla" / "Ripristina" (toggle cancellation)

Sections for future plans:
- Placeholder for RSVP list (Plan 03-03)
- Placeholder for Formation builder (Plan 03-04)

Use useMatch hook to fetch match data.
Show loading skeleton while fetching.
Error state if match not found.

All pages should be Client Components ('use client') since they use hooks.
Follow the same layout patterns from Phase 2 team pages.
  </action>
  <verify>
All pages compile:
npx tsc --noEmit app/[locale]/teams/[teamId]/matches/page.tsx
npx tsc --noEmit app/[locale]/teams/[teamId]/matches/create/page.tsx
npx tsc --noEmit app/[locale]/teams/[teamId]/matches/[matchId]/page.tsx

Navigation works:
- Create button → create page
- Match card → detail page
- Back buttons work
  </verify>
  <done>
Match list page with upcoming/past tabs. Create match page with form. Match detail page with info and admin actions.
  </done>
</task>

</tasks>

<verification>
Before proceeding to Wave 3, verify:
1. User can create a match with date, time, location, mode
2. Match appears in team match list
3. Upcoming/past tabs work correctly
4. Match details page shows all info
5. Admin can edit and cancel matches
6. All forms validate properly with Italian messages
7. Mobile date/time pickers work natively
</verification>

<success_criteria>
- Match CRUD operations work end-to-end
- Match list shows upcoming and past matches
- Match creation form validates all fields
- Match detail page displays complete info
- Admin can edit and cancel matches
- All UI is mobile-optimized (44px+ touch targets)
</success_criteria>

<output>
After completion, create `.planning/phases/03-match-management/03-02-SUMMARY.md`
</output>
