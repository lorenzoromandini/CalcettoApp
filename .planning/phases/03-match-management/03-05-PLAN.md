---
phase: 03-match-management
plan: 05
type: execute
wave: 5
depends_on: ["03-01", "03-02"]
files_modified:
  - app/manifest.ts
  - app/sw.ts
  - lib/notifications/index.ts
  - lib/notifications/push.ts
  - hooks/use-notifications.ts
  - components/notifications/permission-request.tsx
  - supabase/migrations/20260215000003_push_subscriptions.sql
  - .env.local
autonomous: false

user_setup:
  - service: "push notifications"
    why: "VAPID keys required for web push notifications"
    env_vars:
      - name: NEXT_PUBLIC_VAPID_PUBLIC_KEY
        source: "Generate with web-push library or online tool"
      - name: VAPID_PRIVATE_KEY
        source: "Generate with web-push library"
      - name: VAPID_SUBJECT
        source: "mailto:your-email@example.com"
    dashboard_config:
      - task: "Configure VAPID keys in environment"
        location: ".env.local"

must_haves:
  truths:
    - "User can grant notification permission"
    - "Push subscription is stored per user"
    - "Notification sent at configurable time before match (default: 24h, 2h)"
    - "Notification includes match date, time, location"
    - "User can manage notification preferences"
  artifacts:
    - path: "supabase/migrations/20260215000003_push_subscriptions.sql"
      provides: "push_subscriptions table for storing user subscriptions"
    - path: "lib/notifications/push.ts"
      provides: "Push notification utilities (subscribe, unsubscribe, send)"
      exports: ["subscribeToPush", "unsubscribeFromPush", "sendPushNotification"]
    - path: "hooks/use-notifications.ts"
      provides: "React hook for notification permission and subscription"
      exports: ["useNotifications"]
    - path: "components/notifications/permission-request.tsx"
      provides: "UI component for requesting notification permission"
    - path: "app/sw.ts"
      provides: "Service Worker push event handler"
  key_links:
    - from: "app/sw.ts"
      to: "lib/notifications/push.ts"
      via: "push event handling"
      pattern: "event.waitUntil.*showNotification"
    - from: "hooks/use-notifications.ts"
      to: "lib/notifications/push.ts"
      via: "subscribeToPush call"
      pattern: "await subscribeToPush"
---

<objective>
Implement push notification reminders before matches.

Purpose: Keep players informed about upcoming matches and improve attendance.

Output: Complete push notification system with permission handling, subscription storage, scheduled notifications, and user preferences.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-match-management/03-02-SUMMARY.md
@app/manifest.ts
@app/sw.ts
@lib/supabase/client.ts

## Requirements Covered
- MATCH-10: Push notification reminders before match

## Tech Stack Notes
- Web Push API for notifications
- Service Worker for receiving pushes (already in app/sw.ts)
- VAPID keys for server authentication
- Supabase for subscription storage
- Schedule with database triggers or edge functions

## Permission Best Practices (from Research)
- Don't ask immediately on first visit
- Request after demonstrating value (after creating/joining first match)
- Explain WHY before requesting
- Provide easy opt-out in settings

## Notification Content
Title: "Partita tra 2 ore!" / "Match in 2 hours!"
Body: "Stasera alle 20:30 da Calcetto Roma. Ci sei?" / "Tonight at 8:30pm at Calcetto Roma. Coming?"
Icon: App icon
Actions: "Conferma" (Confirm), "Vedi dettagli" (View details)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create push subscription database schema</name>
  <files>
    - supabase/migrations/20260215000003_push_subscriptions.sql
  </files>
  <action>
Create database migration for push subscriptions:

**supabase/migrations/20260215000003_push_subscriptions.sql:**

```sql
-- Push subscriptions table
CREATE TABLE IF NOT EXISTS push_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    subscription JSONB NOT NULL, -- Web Push subscription object
    device_info TEXT, -- Optional: device type, browser
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id) -- One subscription per user (simplified)
);

-- User notification preferences
CREATE TABLE IF NOT EXISTS notification_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    match_reminder_24h BOOLEAN DEFAULT TRUE,
    match_reminder_2h BOOLEAN DEFAULT TRUE,
    match_reminder_30m BOOLEAN DEFAULT FALSE,
    marketing_notifications BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id)
);

-- Notification log (for tracking sent notifications)
CREATE TABLE IF NOT EXISTS notification_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    match_id UUID REFERENCES matches(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL, -- 'reminder_24h', 'reminder_2h', 'reminder_30m'
    title TEXT NOT NULL,
    body TEXT NOT NULL,
    sent_at TIMESTAMPTZ DEFAULT NOW(),
    delivered_at TIMESTAMPTZ,
    clicked_at TIMESTAMPTZ
);

-- Enable RLS
ALTER TABLE push_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_logs ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- push_subscriptions: Users can only see/modify their own
CREATE POLICY "Users can manage own push subscriptions"
    ON push_subscriptions
    FOR ALL
    TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- notification_preferences: Users can only see/modify their own
CREATE POLICY "Users can manage own notification preferences"
    ON notification_preferences
    FOR ALL
    TO authenticated
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- notification_logs: Users can only see their own
CREATE POLICY "Users can view own notification logs"
    ON notification_logs
    FOR SELECT
    TO authenticated
    USING (user_id = auth.uid());

-- Indexes
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user_id ON push_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_notification_preferences_user_id ON notification_preferences(user_id);
CREATE INDEX IF NOT EXISTS idx_notification_logs_user_id ON notification_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_notification_logs_match_id ON notification_logs(match_id);

-- Triggers for updated_at
CREATE TRIGGER push_subscriptions_updated_at
    BEFORE UPDATE ON push_subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER notification_preferences_updated_at
    BEFORE UPDATE ON notification_preferences
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to get users needing reminder (for scheduled jobs)
CREATE OR REPLACE FUNCTION get_users_for_match_reminder(reminder_type VARCHAR)
RETURNS TABLE (
    user_id UUID,
    match_id UUID,
    subscription JSONB,
    match_data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        tm.user_id,
        m.id as match_id,
        ps.subscription,
        jsonb_build_object(
            'scheduled_at', m.scheduled_at,
            'location', m.location,
            'mode', m.mode
        ) as match_data
    FROM matches m
    JOIN team_members tm ON tm.team_id = m.team_id
    JOIN push_subscriptions ps ON ps.user_id = tm.user_id
    LEFT JOIN notification_preferences np ON np.user_id = tm.user_id
    LEFT JOIN notification_logs nl ON nl.match_id = m.id 
        AND nl.user_id = tm.user_id 
        AND nl.type = reminder_type
    WHERE m.status = 'scheduled'
        AND nl.id IS NULL -- Not already sent
        AND CASE reminder_type
            WHEN 'reminder_24h' THEN 
                m.scheduled_at BETWEEN NOW() + INTERVAL '23 hours' AND NOW() + INTERVAL '25 hours'
                AND COALESCE(np.match_reminder_24h, TRUE)
            WHEN 'reminder_2h' THEN 
                m.scheduled_at BETWEEN NOW() + INTERVAL '1 hour' AND NOW() + INTERVAL '3 hours'
                AND COALESCE(np.match_reminder_2h, TRUE)
            WHEN 'reminder_30m' THEN 
                m.scheduled_at BETWEEN NOW() + INTERVAL '15 minutes' AND NOW() + INTERVAL '45 minutes'
                AND COALESCE(np.match_reminder_30m, FALSE)
        END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

This schema supports:
- Storing push subscriptions per user
- User notification preferences (which reminders to receive)
- Notification logs (prevent duplicates, track engagement)
- Helper function for scheduled reminder queries
  </action>
  <verify>
SQL syntax is valid and follows existing migration patterns.
  </verify>
  <done>
Migration file created with push_subscriptions, notification_preferences, notification_logs tables and helper function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create push notification utilities and service worker handler</name>
  <files>
    - lib/notifications/push.ts
    - app/sw.ts
  </files>
  <action>
Create push notification infrastructure:

**lib/notifications/push.ts:**

```typescript
import { createClient } from '@/lib/supabase/client';

const VAPID_PUBLIC_KEY = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY!;

export interface PushSubscriptionData {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
}

// Check if push is supported
export function isPushSupported(): boolean {
  return 'serviceWorker' in navigator && 'PushManager' in window;
}

// Check current permission status
export async function getNotificationPermission(): Promise<NotificationPermission> {
  if (!('Notification' in window)) return 'default';
  return Notification.permission;
}

// Request permission and subscribe
export async function subscribeToPush(): Promise<PushSubscriptionData | null> {
  if (!isPushSupported()) {
    throw new Error('Push notifications not supported');
  }

  // Request permission
  const permission = await Notification.requestPermission();
  if (permission !== 'granted') {
    return null;
  }

  // Get service worker registration
  const registration = await navigator.serviceWorker.ready;

  // Subscribe to push
  const subscription = await registration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY),
  });

  // Convert to JSON
  const subscriptionData: PushSubscriptionData = {
    endpoint: subscription.endpoint,
    keys: {
      p256dh: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('p256dh')!))),
      auth: btoa(String.fromCharCode(...new Uint8Array(subscription.getKey('auth')!))),
    },
  };

  // Save to database
  const supabase = createClient();
  await supabase
    .from('push_subscriptions')
    .upsert({
      subscription: subscriptionData,
    }, { onConflict: 'user_id' });

  return subscriptionData;
}

// Unsubscribe from push
export async function unsubscribeFromPush(): Promise<void> {
  const registration = await navigator.serviceWorker.ready;
  const subscription = await registration.pushManager.getSubscription();
  
  if (subscription) {
    await subscription.unsubscribe();
  }

  // Remove from database
  const supabase = createClient();
  await supabase
    .from('push_subscriptions')
    .delete()
    .eq('user_id', (await supabase.auth.getUser()).data.user?.id);
}

// Helper to convert VAPID key
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  return Uint8Array.from([...rawData].map(char => char.charCodeAt(0)));
}

// Send local notification (for testing)
export async function sendLocalNotification(
  title: string,
  options?: NotificationOptions
): Promise<void> {
  if (Notification.permission !== 'granted') return;
  
  const registration = await navigator.serviceWorker.ready;
  await registration.showNotification(title, options);
}
```

**Update app/sw.ts:**

Add push event handler to existing service worker:

```typescript
// Add to existing sw.ts

// Push notification handler
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();
  
  const options: NotificationOptions = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: data.tag || 'match-reminder',
    requireInteraction: false,
    actions: data.actions || [
      { action: 'confirm', title: 'Ci sono!' },
      { action: 'view', title: 'Vedi dettagli' },
    ],
    data: {
      url: data.url || '/',
      matchId: data.matchId,
    },
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Notification click handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const data = event.notification.data;
  let url = data?.url || '/';

  // Handle actions
  if (event.action === 'confirm') {
    // Could track confirmation or navigate to RSVP
    url = data?.url ? `${data.url}?rsvp=in` : '/';
  } else if (event.action === 'view') {
    url = data?.url || '/';
  }

  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      // Focus existing window if open
      for (const client of clientList) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    })
  );
});
```

Update manifest.ts to include gcm_sender_id if needed (for Chrome Android):
```typescript
// In app/manifest.ts
gcm_sender_id: '103953800507', // Default FCM sender ID for web push
```
  </action>
  <verify>
TypeScript compiles:
npx tsc --noEmit lib/notifications/push.ts

Service worker has valid push event handler syntax.
  </verify>
  <done>
Push utilities created with subscribe/unsubscribe functions. Service worker updated with push event and notification click handlers.
  </done>
</task>

<task type="checkpoint:human-action">
  <name>Task 3: Generate VAPID keys and configure environment</name>
  <action>
Generate VAPID keys for web push authentication:

**Instructions:**
1. Install web-push globally or use npx:
   ```bash
   npx web-push generate-vapid-keys
   ```

2. Copy the generated keys and add to .env.local:
   ```
   NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here
   VAPID_PRIVATE_KEY=your_private_key_here
   VAPID_SUBJECT=mailto:your-email@example.com
   ```

3. The public key will be used in the browser (NEXT_PUBLIC_ prefix)
4. The private key stays server-side only
5. The subject should be a contact email for the push service

**Important:**
- Keep private key secret - never commit to git
- Add .env.local to .gitignore if not already there
- Public key can be exposed to client safely

After adding to .env.local, restart the development server.
  </action>
  <resume-signal>Type "done" when VAPID keys are configured in .env.local</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Create notification hooks and UI components</name>
  <files>
    - hooks/use-notifications.ts
    - components/notifications/permission-request.tsx
  </files>
  <action>
Create notification React hooks and UI:

**hooks/use-notifications.ts:**

```typescript
import { useState, useEffect, useCallback } from 'react';
import {
  isPushSupported,
  getNotificationPermission,
  subscribeToPush,
  unsubscribeFromPush,
  sendLocalNotification,
} from '@/lib/notifications/push';
import { createClient } from '@/lib/supabase/client';

export function useNotifications() {
  const [isSupported, setIsSupported] = useState(false);
  const [permission, setPermission] = useState<NotificationPermission>('default');
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [preferences, setPreferences] = useState({
    match_reminder_24h: true,
    match_reminder_2h: true,
    match_reminder_30m: false,
  });

  useEffect(() => {
    setIsSupported(isPushSupported());
    checkPermission();
    loadPreferences();
  }, []);

  const checkPermission = async () => {
    const perm = await getNotificationPermission();
    setPermission(perm);
    setIsSubscribed(perm === 'granted');
  };

  const loadPreferences = async () => {
    const supabase = createClient();
    const { data } = await supabase
      .from('notification_preferences')
      .select('*')
      .single();
    
    if (data) {
      setPreferences({
        match_reminder_24h: data.match_reminder_24h,
        match_reminder_2h: data.match_reminder_2h,
        match_reminder_30m: data.match_reminder_30m,
      });
    }
  };

  const requestPermission = useCallback(async () => {
    setIsLoading(true);
    try {
      await subscribeToPush();
      await checkPermission();
      return true;
    } catch (err) {
      console.error('Failed to subscribe:', err);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const disableNotifications = useCallback(async () => {
    setIsLoading(true);
    try {
      await unsubscribeFromPush();
      await checkPermission();
    } finally {
      setIsLoading(false);
    }
  }, []);

  const updatePreferences = useCallback(async (newPrefs: Partial<typeof preferences>) => {
    const updated = { ...preferences, ...newPrefs };
    setPreferences(updated);

    const supabase = createClient();
    await supabase
      .from('notification_preferences')
      .upsert({
        match_reminder_24h: updated.match_reminder_24h,
        match_reminder_2h: updated.match_reminder_2h,
        match_reminder_30m: updated.match_reminder_30m,
      }, { onConflict: 'user_id' });
  }, [preferences]);

  const testNotification = useCallback(async () => {
    await sendLocalNotification('Test Notifica', {
      body: 'Le notifiche funzionano correttamente!',
      icon: '/icons/icon-192x192.png',
    });
  }, []);

  return {
    isSupported,
    permission,
    isSubscribed,
    isLoading,
    preferences,
    requestPermission,
    disableNotifications,
    updatePreferences,
    testNotification,
  };
}
```

**components/notifications/permission-request.tsx:**

```typescript
interface PermissionRequestProps {
  onRequest: () => void;
  onDismiss: () => void;
}

export function PermissionRequest({ onRequest, onDismiss }: PermissionRequestProps)
```

Design:
- Card/banner style (not intrusive modal)
- Icon: Bell with notification indicator
- Title: "Rimani aggiornato sulle partite"
- Description: "Ricevi promemoria prima delle partite e aggiornamenti sulle convocazioni."
- Primary button: "Attiva notifiche"
- Secondary link: "Non ora" (dismiss)
- Only show if permission === 'default'

**Usage pattern:**
Show permission request:
- After user creates first match
- After user RSVPs to first match
- NOT on first app open (too early)
- Can also be in settings page

**Settings integration:**
Add to team settings or profile settings:
- Toggle for notification permission
- Individual reminder toggles (24h, 2h, 30m)
- Test notification button
- Explanation text

Add translations:
- "notifications.title": "Notifiche"
- "notifications.enable": "Attiva notifiche"
- "notifications.description": "Ricevi promemoria prima delle partite"
- "notifications.reminder24h": "Promemoria 24 ore prima"
- "notifications.reminder2h": "Promemoria 2 ore prima"
- "notifications.test": "Prova notifica"
  </action>
  <verify>
TypeScript compiles:
npx tsc --noEmit hooks/use-notifications.ts components/notifications/permission-request.tsx

Hook exports correct interface.
  </verify>
  <done>
Notification hook with permission handling and preferences. Permission request UI component created.
  </done>
</task>

</tasks>

<verification>
Before proceeding to Wave 6, verify:
1. VAPID keys are configured in .env.local
2. Push subscription saves to database
3. Service worker receives push events
4. Notifications display correctly
5. Permission request appears at appropriate time
6. User can manage notification preferences
7. Clicking notification navigates correctly
</verification>

<success_criteria>
- Push notification permission can be granted
- Subscriptions stored in database per user
- Service Worker handles push events
- Notification preferences configurable
- Reminders scheduled (24h, 2h before match)
- Notifications include match details
- Mobile devices receive notifications correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-match-management/03-05-SUMMARY.md`
</output>
