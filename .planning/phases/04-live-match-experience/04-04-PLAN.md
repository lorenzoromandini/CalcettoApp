---
phase: 04-live-match-experience
plan: "04"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [
  "lib/db/match-events.ts",
  "hooks/use-match-events.ts",
  "components/matches/event-recorder.tsx"
]
autonomous: true

must_haves:
  truths:
    - "User can record goals with player attribution and team"
    - "User can record assists linked to goals"
    - "User can record yellow/red cards with optional reason"
    - "Events recorded with current match time automatically"
    - "Optimistic updates show events immediately, confirmed by server"
  artifacts:
    - path: "lib/db/match-events.ts"
      provides: "Event CRUD with optimistic updates"
      exports: ["recordEvent", "getMatchEvents", "deleteEvent"]
    - path: "hooks/use-match-events.ts"
      provides: "React hook for event recording"
      contains: ["addEvent", "events", "optimisticEvents"]
    - path: "components/matches/event-recorder.tsx"
      provides: "Event recording UI with large touch targets"
      min_size: "120 lines"
  key_links:
    - from: "useMatchEvents hook"
      to: "lib/db/match-events.ts"
      via: "addEvent function"
      pattern: "await recordEvent(event)"
    - from: "EventRecorder component"
      to: "useMatchTimer hook"
      via: "elapsed time"
      pattern: "matchTimeSeconds={timer.elapsedSeconds}"
    - from: "Event recording"
      to: "match_events table"
      via: "Supabase INSERT"
      pattern: "supabase.from('match_events').insert()"
---

<objective>
Implement event recording system for goals, assists, and cards with optimistic updates.

Purpose: Enable match recorders to capture game events efficiently with immediate UI feedback.
Output: Event database operations, recording hook with optimistic updates, and mobile-optimized recorder UI.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-live-match-experience/04-RESEARCH.md (Pattern 4: Optimistic updates, Pitfall #3)
@lib/db/schema.ts (MatchEvent type from 04-01)
@hooks/use-rsvps.ts (Optimistic update pattern from Phase 3)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event database operations</name>
  <files>lib/db/match-events.ts</files>
  <action>
    Create lib/db/match-events.ts with event CRUD operations:

    1. Import dependencies:
       - supabase client from lib/supabase/client
       - getDB, MATCH_EVENTS_STORE from lib/db/index
       - MatchEvent, MatchEventType from lib/db/schema
       - queueOfflineAction from lib/db/actions

    2. Functions to implement:
       ```typescript
       export interface RecordEventInput {
         matchId: string;
         eventType: MatchEventType;
         playerId: string;
         playerIdSecondary?: string; // For assists
         teamId: string;
         matchTimeSeconds: number;
         metadata?: MatchEvent['metadata'];
       }

       export async function recordEvent(
         input: RecordEventInput,
         recordedBy: string
       ): Promise<{ data: MatchEvent | null; error: Error | null }>
       ```
       - Generate UUID client-side using crypto.randomUUID() for offline support
       - Create MatchEvent object with all required fields
       - Optimistic insert to IndexedDB first with sync_status='pending'
       - Try Supabase insert, update IndexedDB with server response
       - If offline, queue for background sync via queueOfflineAction

       ```typescript
       export async function getMatchEvents(matchId: string): Promise<MatchEvent[]>
       ```
       - Fetch from IndexedDB first for instant display
       - Fetch from Supabase, merge with local (server wins conflicts)
       - Sort by client_timestamp for consistent ordering
       - Update IndexedDB with server data

       ```typescript
       export async function deleteEvent(eventId: string): Promise<void>
       ```
       - Soft delete or hard delete based on requirements
       - Optimistic removal from IndexedDB
       - Supabase delete with error handling

       ```typescript
       export async function updateEventMetadata(
         eventId: string,
         metadata: Partial<MatchEvent['metadata']>
       ): Promise<void>
       ```
       - For adding card reasons, correcting goal types, etc.

    3. Conflict resolution (Pitfall #3 prevention):
       - Use client-generated UUIDs to prevent duplicate events
       - Include client_timestamp for ordering when server timestamps match
       - Store recorded_by for audit trail

    4. Helper functions:
       - formatMatchTime(seconds: number): string â†’ "MM:SS" format
       - calculateTeamScore(events: MatchEvent[], teamId: string): number

    5. Error handling:
       - Distinguish network errors from validation errors
       - Retry with exponential backoff for transient failures
       - Mark events with sync_status='error' on permanent failure
  </action>
  <verify>All CRUD functions exist with proper optimistic updates and offline handling</verify>
  <done>Event database operations with client-generated UUIDs and optimistic updates</done>
</task>

<task type="auto">
  <name>Task 2: Create match events hook with optimistic updates</name>
  <files>hooks/use-match-events.ts</files>
  <action>
    Create hooks/use-match-events.ts for managing match events:

    1. Hook signature:
       ```typescript
       export function useMatchEvents(matchId: string) {
         const [events, setEvents] = useState<MatchEvent[]>([]);
         const [isLoading, setIsLoading] = useState(true);
         const [pendingEvents, setPendingEvents] = useState<Set<string>>(new Set());
         
         const addEvent = useCallback(async (input: RecordEventInput) => { ... });
         const removeEvent = useCallback(async (eventId: string) => { ... });
         const refreshEvents = useCallback(async () => { ... });
         
         return {
           events,
           isLoading,
           pendingEvents,
           addEvent,
           removeEvent,
           refreshEvents,
           getTeamScore: (teamId: string) => number
         };
       }
       ```

    2. Implementation:
       - Fetch initial events on mount using getMatchEvents
       - Maintain events array in state
       - Track pendingEvents (optimistic events not yet confirmed)

    3. Optimistic addEvent flow:
       - Generate optimistic event with crypto.randomUUID()
       - Add to events array immediately with sync_status='pending'
       - Add eventId to pendingEvents Set
       - Call recordEvent from lib/db/match-events
       - On success: Update event with server data, remove from pendingEvents
       - On error: Mark event sync_status='error', keep in list for retry

    4. Realtime integration:
       - Subscribe to INSERT events on match_events table
       - When new event arrives:
         * If from this client (event id in pendingEvents): confirm it
         * If from other client: add to events array
       - Subscribe to DELETE events to remove deleted events

    5. Score calculation:
       ```typescript
       const getTeamScore = useCallback((teamId: string) => {
         return events.filter(e => 
           (e.event_type === 'goal' && e.team_id === teamId) ||
           (e.event_type === 'own_goal' && e.team_id !== teamId)
         ).length;
       }, [events]);
       ```

    6. Event ordering:
       - Sort by client_timestamp ascending
       - Secondary sort by server timestamp
       - Goals/assists at same timestamp should show assist after goal

    7. Offline handling:
       - Show pending indicator for optimistic events
       - Show error state for failed syncs with retry button
       - Auto-retry when connection restored
  </action>
  <verify>Hook manages events with optimistic updates, tracks pending states, calculates scores</verify>
  <done>Match events hook with optimistic updates and realtime sync</done>
</task>

<task type="auto">
  <name>Task 3: Create event recorder UI component</name>
  <files>components/matches/event-recorder.tsx</files>
  <action>
    Create components/matches/event-recorder.tsx for recording match events:

    1. Component signature:
       ```typescript
       interface EventRecorderProps {
         matchId: string;
         teamId: string;
         players: Player[]; // Available players for this team
         currentTimeSeconds: number;
         onEventRecorded?: (event: MatchEvent) => void;
       }

       export function EventRecorder({
         matchId,
         teamId,
         players,
         currentTimeSeconds,
         onEventRecorded
       }: EventRecorderProps)
       ```

    2. State management:
       - selectedEventType: 'goal' | 'assist' | 'yellow_card' | 'red_card' | null
       - selectedPlayerId: string | null
       - selectedSecondaryPlayerId: string | null (for assists)
       - showCardReasonInput: boolean
       - cardReason: string

    3. Mobile-optimized UI layout (from RESEARCH.md Pattern 4):
       ```
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  [ âš½ GOAL ] [ ğŸ¯ ASSIST ]          â”‚
       â”‚  [ ğŸŸ¨ CARD ] [ ğŸŸ¥ CARD  ]          â”‚
       â”‚                                     â”‚
       â”‚  Select Player:                     â”‚
       â”‚  [Marco] [Luca] [Giuseppe] ...     â”‚
       â”‚                                     â”‚
       â”‚  [    RECORD EVENT    ]            â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       ```

    4. Event type selector:
       - Large buttons (min 72x72px, target 80x80px)
       - Visual icons: âš½ for goal, ğŸ¯ for assist, ğŸŸ¨/ğŸŸ¥ for cards
       - Selected state with clear visual indicator
       - touch-action: none to prevent browser gestures

    5. Player selector:
       - Scrollable horizontal list of player buttons
       - Show avatar + name for each player
       - Minimum 64px touch targets
       - Highlight selected player

    6. Secondary player (for assists):
       - Show only when event type is 'assist' or 'goal'
       - "Who assisted?" label
       - Same player selector component
       - Allow "No assist" option

    7. Card reason input:
       - Show when card type selected
       - Optional text field with placeholder "Reason (optional)"
       - Large touch target for input

    8. Record button:
       - Full width, minimum 56px height
       - Disabled state until player selected
       - Loading state while recording
       - Success feedback (toast or inline)

    9. Recording flow:
       - User selects event type
       - User selects primary player
       - User selects secondary player if needed
       - User enters card reason if card
       - User taps Record
       - Call addEvent from useMatchEvents hook
       - Reset form after successful record
       - Call onEventRecorded callback

    10. Accessibility:
        - aria-labels on all buttons
        - Keyboard navigation support
        - Focus indicators
        - Screen reader announcements for recorded events

    11. Styling:
        - Container: bg-white dark:bg-slate-800 rounded-xl p-4
        - Event buttons: Large with icons, color-coded (green goal, yellow card, red card)
        - Player buttons: Avatar + name, selectable state
        - Record button: Primary color, full width
  </action>
  <verify>Component has large touch targets, event type buttons, player selection, record flow</verify>
  <done>Event recorder UI with mobile-optimized large touch targets</done>
</task>

</tasks>

<verification>
- Events recorded with current match time automatically
- Optimistic updates show events immediately before server confirm
- Multiple simultaneous recorders don't lose events
- Large touch targets work with wet fingers
- Card reasons captured and displayed
</verification>

<success_criteria>
1. lib/db/match-events.ts exists with CRUD operations
2. hooks/use-match-events.ts exists with optimistic updates
3. components/matches/event-recorder.tsx exists with event UI
4. Client-generated UUIDs prevent duplicate events
5. Minimum 64px touch targets on all interactive elements
6. Events include match time and player attribution
</success_criteria>

<output>
After completion, create `.planning/phases/04-live-match-experience/04-04-SUMMARY.md`
</output>
