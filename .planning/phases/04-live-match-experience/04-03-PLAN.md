---
phase: 04-live-match-experience
plan: "03"
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [
  "hooks/use-realtime-match.ts",
  "hooks/use-realtime-connection.ts",
  "components/matches/scoreboard.tsx"
]
autonomous: true

must_haves:
  truths:
    - "Scoreboard displays current score (home/away) from match state"
    - "Score updates in real-time for all connected users"
    - "Connection state visible (connected/connecting/disconnected)"
    - "Heartbeat monitoring detects silent disconnections"
    - "UI re-syncs when connection restored after disconnection"
  artifacts:
    - path: "hooks/use-realtime-match.ts"
      provides: "Supabase Realtime subscription for match updates"
      contains: ["supabase.channel", "on('postgres_changes')", "subscribe"]
    - path: "hooks/use-realtime-connection.ts"
      provides: "Connection state with heartbeat monitoring"
      contains: ["heartbeatIntervalMs", "heartbeatCallback", "connectionState"]
    - path: "components/matches/scoreboard.tsx"
      provides: "Live scoreboard UI component"
      min_size: "80 lines"
  key_links:
    - from: "useRealtimeMatch hook"
      to: "supabase.channel"
      via: "Realtime channel subscription"
      pattern: "supabase.channel(`match:${matchId}`)"
    - from: "useRealtimeConnection hook"
      to: "Supabase heartbeat"
      via: "realtime config"
      pattern: "heartbeatCallback: (status) => {...}"
    - from: "Scoreboard component"
      to: "useRealtimeMatch hook"
      via: "props or context"
      pattern: "const { score, events } = useRealtimeMatch(matchId)"
---

<objective>
Implement real-time scoreboard with Supabase Realtime, heartbeat monitoring, and connection state management.

Purpose: Enable all users to see live match updates instantly, with robust connection handling for mobile browser challenges.
Output: Realtime hooks with heartbeat monitoring, connection state tracking, and scoreboard UI component.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-live-match-experience/04-RESEARCH.md (Pattern 2: Supabase Realtime with heartbeat, Pitfall #1)
@hooks/use-rsvps.ts (Existing real-time subscription pattern from Phase 3)
@lib/db/matches.ts (Match data operations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create realtime connection monitoring hook</name>
  <files>hooks/use-realtime-connection.ts</files>
  <action>
    Create hooks/use-realtime-connection.ts for connection state and heartbeat:

    1. Hook signature:
       ```typescript
       export function useRealtimeConnection() {
         const [connectionState, setConnectionState] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');
         const [lastHeartbeat, setLastHeartbeat] = useState<Date | null>(null);
         const [heartbeatTimeout, setHeartbeatTimeout] = useState(false);
         
         return {
           connectionState,
           lastHeartbeat,
           heartbeatTimeout,
           isConnected: connectionState === 'connected' && !heartbeatTimeout
         };
       }
       ```

    2. Implementation based on RESEARCH.md Pattern 2:
       - Configure Supabase client with custom realtime settings
       - Set heartbeatIntervalMs to 15000 (15 seconds, shorter than default 25s for mobile)
       - Implement heartbeatCallback that:
         * On 'ok': update lastHeartbeat, clear timeout flag
         * On 'timeout': set heartbeatTimeout flag, set connectionState to 'disconnected'
       - Listen for visibilitychange to reconnect when tab becomes visible
       - Track connection lifecycle: connecting → connected → disconnected → reconnecting

    3. Configuration:
       ```typescript
       const supabase = createClient(SUPABASE_URL, SUPABASE_KEY, {
         realtime: {
           heartbeatIntervalMs: 15000,
           heartbeatCallback: (status) => {
             if (status === 'timeout') {
               setHeartbeatTimeout(true);
               setConnectionState('disconnected');
             } else if (status === 'ok') {
               setHeartbeatTimeout(false);
               setLastHeartbeat(new Date());
             }
           }
         }
       });
       ```

    4. Mobile-specific handling:
       - Reconnect on visibilitychange when hidden → visible
       - Exponential backoff for reconnection attempts
       - Clear reconnection timer on unmount

    5. Return additional helpers:
       - reconnect(): manually trigger reconnection
       - connectionQuality: 'good' | 'poor' | 'offline' based on heartbeat timing
  </action>
  <verify>Hook exports connection state, heartbeat status, and reconnect function</verify>
  <done>Realtime connection monitoring with 15s heartbeat interval</done>
</task>

<task type="auto">
  <name>Task 2: Create realtime match subscription hook</name>
  <files>hooks/use-realtime-match.ts</files>
  <action>
    Create hooks/use-realtime-match.ts for subscribing to match events:

    1. Hook signature:
       ```typescript
       export function useRealtimeMatch(matchId: string) {
         const [events, setEvents] = useState<MatchEvent[]>([]);
         const [score, setScore] = useState({ home: 0, away: 0 });
         const [timer, setTimer] = useState<MatchTimer | null>(null);
         const [isLoading, setIsLoading] = useState(true);
         
         return {
           events,
           score,
           timer,
           isLoading,
           connectionState,
           refetch
         };
       }
       ```

    2. Implementation:
       - Use supabase.channel() to create named channel: `match:${matchId}`
       - Subscribe to postgres_changes on match_events table with filter `match_id=eq.${matchId}`
       - Subscribe to postgres_changes on match_timers table with filter `match_id=eq.${matchId}`
       - Subscribe to postgres_changes on matches table for score updates

    3. Channel configuration:
       ```typescript
       const channel = supabase
         .channel(`match:${matchId}`, {
           config: {
             broadcast: { self: true } // Receive own broadcasts for confirmation
           }
         })
         .on('postgres_changes', 
           { event: 'INSERT', schema: 'public', table: 'match_events', filter: `match_id=eq.${matchId}` },
           handleNewEvent
         )
         .on('postgres_changes',
           { event: 'UPDATE', schema: 'public', table: 'match_timers', filter: `match_id=eq.${matchId}` },
           handleTimerUpdate
         )
         .subscribe((status) => {
           setConnectionState(status === 'SUBSCRIBED' ? 'connected' : 'disconnected');
           if (status === 'SUBSCRIBED') setIsLoading(false);
         });
       ```

    4. Event handlers:
       - handleNewEvent: Add event to events array, recalculate score if goal/own_goal
       - handleTimerUpdate: Update timer state for UI sync
       - Sort events by client_timestamp for consistent ordering

    5. Initial data fetch:
       - Fetch existing events and timer state on mount
       - Merge with realtime updates
       - Handle race conditions (deduplicate by event ID)

    6. Score calculation:
       - Derive home/away scores from events array
       - goal events increment scorer's team
       - own_goal increments opposing team
       - Update whenever events change

    7. Cleanup:
       - Remove channel on unmount
       - Clear subscription to prevent memory leaks
  </action>
  <verify>Hook subscribes to match_events, match_timers, matches; returns events, score, timer</verify>
  <done>Realtime match subscription with postgres_changes listeners</done>
</task>

<task type="auto">
  <name>Task 3: Create scoreboard UI component</name>
  <files>components/matches/scoreboard.tsx</files>
  <action>
    Create components/matches/scoreboard.tsx displaying live score:

    1. Component signature:
       ```typescript
       interface ScoreboardProps {
         matchId: string;
         teamAName: string;
         teamBName: string;
         showTimer?: boolean;
       }

       export function Scoreboard({ matchId, teamAName, teamBName, showTimer = true }: ScoreboardProps)
       ```

    2. Use hooks:
       - useRealtimeMatch(matchId) for events, score, timer, connectionState
       - useMatchTimer integration if showTimer is true
       - Format time from timer or useMatchTimer hook

    3. Layout (mobile-optimized):
       ```
       ┌─────────────────────────────────────┐
       │  Team A      [Score]      Team B   │
       │  [Name]      [ 2-1 ]      [Name]   │
       │                                     │
       │  [    Timer: 34:52    ]            │
       │  [● Connected]                      │
       └─────────────────────────────────────┘
       ```

    4. Visual design:
       - Large score display (minimum 48px font for visibility in sunlight)
       - Team names truncated with ellipsis if too long
       - Timer in monospace font for stability
       - Connection indicator: green dot + "Connected" / yellow "Connecting..." / red "Offline"

    5. Mobile UX from RESEARCH.md:
       - touch-action: none on scoreboard to prevent pull-to-refresh
       - High contrast colors (white text on dark background)
       - Minimum 44px touch targets for any interactive elements

    6. States to handle:
       - Loading: Show skeleton or spinner
       - Connected with data: Show score and timer
       - Disconnected: Show cached score with offline indicator
       - No events yet: Show 0-0 with "Match starting..."

    7. Accessibility:
       - aria-live="polite" on score for screen readers
       - aria-label describing current score
       - Focus management for keyboard navigation

    8. Styling with Tailwind:
       - Container: bg-slate-900 text-white rounded-xl p-4
       - Score: text-5xl font-bold tabular-nums
       - Timer: text-2xl font-mono text-slate-300
       - Connection: text-xs with status color
  </action>
  <verify>Component renders score, timer, connection state; follows mobile patterns</verify>
  <done>Scoreboard component with real-time updates and connection status</done>
</task>

</tasks>

<verification>
- Scoreboard shows live score from Supabase Realtime updates
- Connection indicator shows correct state during network changes
- Heartbeat timeout triggers reconnection logic
- UI updates immediately when goal event received
- Works with multiple connected clients viewing same match
</verification>

<success_criteria>
1. hooks/use-realtime-connection.ts exists with heartbeat monitoring
2. hooks/use-realtime-match.ts exists with match subscription
3. components/matches/scoreboard.tsx exists with live display
4. Heartbeat interval set to 15s for mobile reliability
5. Connection state visible to user
6. Score auto-updates when events arrive
</success_criteria>

<output>
After completion, create `.planning/phases/04-live-match-experience/04-03-SUMMARY.md`
</output>
