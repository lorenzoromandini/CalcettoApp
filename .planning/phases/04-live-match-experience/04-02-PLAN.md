---
phase: 04-live-match-experience
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified: [
  "lib/db/match-timers.ts",
  "hooks/use-match-timer.ts",
  "hooks/use-wake-lock.ts"
]
autonomous: true

must_haves:
  truths:
    - "Timer accurately tracks elapsed time using performance.now()"
    - "Timer can be started, paused, and resumed without losing accuracy"
    - "Timer handles browser backgrounding and visibility changes"
    - "Timer state persists to database for multi-device coordination"
    - "Screen wake lock prevents device sleep during active match"
  artifacts:
    - path: "hooks/use-match-timer.ts"
      provides: "Accurate match timer with start/pause/resume"
      contains: ["performance.now()", "visibilitychange", "start", "pause", "resume"]
    - path: "hooks/use-wake-lock.ts"
      provides: "Screen wake lock management"
      contains: ["navigator.wakeLock", "request('screen')"]
    - path: "lib/db/match-timers.ts"
      provides: "Timer CRUD with offline support"
      exports: ["getMatchTimer", "startMatchTimer", "pauseMatchTimer", "resumeMatchTimer"]
  key_links:
    - from: "useMatchTimer hook"
      to: "useWakeLock hook"
      via: "isRunning state"
      pattern: "useWakeLock(isRunning)"
    - from: "useMatchTimer hook"
      to: "match_timers table"
      via: "lib/db/match-timers.ts"
      pattern: "syncTimerToServer()"
---

<objective>
Implement accurate match timer with pause/resume, visibility handling, and screen wake lock.

Purpose: Provide reliable match timing that works accurately across browser backgrounding, device sleep, and supports pitch-side recording with mobile UX.
Output: Timer hooks with performance.now()-based elapsed time calculation, wake lock hook, database operations with offline support.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-live-match-experience/04-RESEARCH.md (Timer patterns, Pitfall #2)
@lib/db/schema.ts (MatchTimer interface from 04-01)
@lib/db/matches.ts (Existing match CRUD patterns)
@hooks/use-matches.ts (Existing match hook patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create screen wake lock hook</name>
  <files>hooks/use-wake-lock.ts</files>
  <action>
    Create hooks/use-wake-lock.ts implementing Screen Wake Lock API:

    1. Hook signature:
       ```typescript
       export function useWakeLock(enabled: boolean) {
         const [isLocked, setIsLocked] = useState(false);
         const [error, setError] = useState<Error | null>(null);
         // ...
         return { isLocked, error, supported: 'wakeLock' in navigator };
       }
       ```

    2. Implementation:
       - Check 'wakeLock' in navigator for feature support
       - Use useRef to store WakeLockSentinel
       - When enabled changes to true: request wake lock via navigator.wakeLock.request('screen')
       - When enabled changes to false: release wake lock
       - Add event listener for 'release' event to update state
       - Listen for visibilitychange: re-acquire lock when tab becomes visible if still enabled
       - Handle errors gracefully (battery restrictions, etc.)

    3. Critical patterns from RESEARCH.md:
       - Locks auto-release when tab hidden → must re-acquire on visibilitychange
       - Some browsers may deny lock (battery saver) → handle gracefully
       - Always release in cleanup function to prevent memory leaks

    4. Return values:
       - isLocked: boolean - whether wake lock is currently held
       - error: Error | null - any error acquiring/releasing lock
       - supported: boolean - whether browser supports wake lock API
  </action>
  <verify>Hook exports useWakeLock with enabled param, returns isLocked/error/supported</verify>
  <done>Screen wake lock hook with visibilitychange re-acquisition</done>
</task>

<task type="auto">
  <name>Task 2: Create accurate match timer hook</name>
  <files>hooks/use-match-timer.ts</files>
  <action>
    Create hooks/use-match-timer.ts with performance.now()-based timing:

    1. Hook signature:
       ```typescript
       export function useMatchTimer(matchId: string, initialElapsedSeconds = 0) {
         const [elapsedMs, setElapsedMs] = useState(initialElapsedSeconds * 1000);
         const [isRunning, setIsRunning] = useState(false);
         const [status, setStatus] = useState<'idle' | 'running' | 'paused'>('idle');
         
         const start = useCallback(() => { ... });
         const pause = useCallback(() => { ... });
         const resume = useCallback(() => { ... });
         const reset = useCallback(() => { ... });
         
         return {
           elapsedMs,
           elapsedSeconds: Math.floor(elapsedMs / 1000),
           isRunning,
           status,
           formattedTime: formatTime(elapsedMs),
           start,
           pause,
           resume,
           reset
         };
       }
       ```

    2. Core timing logic (Pattern 1 from RESEARCH.md):
       - Use useRef for mutable refs: startTimeRef, pausedElapsedRef
       - start(): Record performance.now() in startTimeRef, set isRunning=true
       - pause(): Calculate delta = performance.now() - startTimeRef, add to pausedElapsedRef, set elapsedMs, set isRunning=false
       - resume(): Set startTimeRef to performance.now(), set isRunning=true
       - reset(): Clear all refs, set elapsedMs=0, set isRunning=false

    3. Visibility change handling (Pitfall #2 prevention):
       - Listen for document.visibilitychange
       - When hidden while running: store current elapsed, clear startTimeRef
       - When visible while should be running: set startTimeRef to performance.now()
       - This prevents timer drift during backgrounding

    4. Display update loop:
       - useEffect with setInterval (100ms for smooth display)
       - While running: calculate elapsed = (now - startTimeRef) + pausedElapsedRef
       - Update elapsedMs state
       - Cleanup interval on unmount or pause

    5. Helper functions:
       - formatTime(ms: number): string → returns "MM:SS" format
       - pad(num: number): string → zero-pads single digits

    6. Server sync:
       - Debounced sync to server every 5 seconds while running
       - Immediate sync on pause
       - Use lib/db/match-timers functions (created in Task 3)
  </action>
  <verify>Hook uses performance.now() refs, handles visibilitychange, provides formatted time</verify>
  <done>Accurate timer hook with pause/resume and visibility handling</done>
</task>

<task type="auto">
  <name>Task 3: Create timer database operations</name>
  <files>lib/db/match-timers.ts</files>
  <action>
    Create lib/db/match-timers.ts with timer CRUD operations:

    1. Import dependencies:
       - supabase from lib/supabase/client
       - getDB, MATCH_TIMERS_STORE from lib/db/index
       - MatchTimer type from lib/db/schema
       - queueOfflineAction from lib/db/actions

    2. Functions to implement:
       ```typescript
       export async function getMatchTimer(matchId: string): Promise<MatchTimer | null>
       ```
       - Try IndexedDB first for offline support
       - Fallback to Supabase query
       - Return null if no timer exists

       ```typescript
       export async function startMatchTimer(matchId: string): Promise<void>
       ```
       - Insert record with started_at=now, is_running=true, total_elapsed_seconds=0
       - Optimistic update to IndexedDB
       - Queue for sync if offline

       ```typescript
       export async function pauseMatchTimer(matchId: string, elapsedSeconds: number): Promise<void>
       ```
       - Update record with paused_at=now, is_running=false, total_elapsed_seconds
       - Sync immediately to preserve state
       - Update IndexedDB

       ```typescript
       export async function resumeMatchTimer(matchId: string): Promise<void>
       ```
       - Update record with started_at=now, is_running=true
       - Clear paused_at
       - Update IndexedDB

       ```typescript
       export async function getTimerFromIndexedDB(matchId: string): Promise<MatchTimer | null>
       ```
       - Helper for offline-first access

    3. RLS considerations:
       - All operations check user is match participant
       - Supabase RLS handles authorization
       - Handle 403 errors gracefully

    4. Error handling:
       - Try server first, fallback to IndexedDB
       - Queue for background sync on failure
       - Return offline status indicator
  </action>
  <verify>All CRUD functions exist with proper error handling and offline support</verify>
  <done>Timer database operations with offline-first architecture</done>
</task>

</tasks>

<verification>
- Timer hook maintains accuracy across 10-minute test with pauses
- Wake lock keeps screen on when timer running
- Visibility change doesn't cause timer drift
- Database operations work offline and sync when reconnected
</verification>

<success_criteria>
1. hooks/use-wake-lock.ts exists with useWakeLock hook
2. hooks/use-match-timer.ts exists with performance.now()-based timing
3. lib/db/match-timers.ts exists with CRUD operations
4. Timer handles visibilitychange without drift
5. Wake lock re-acquires after tab becomes visible
6. All files follow existing code patterns from Phase 3
</success_criteria>

<output>
After completion, create `.planning/phases/04-live-match-experience/04-02-SUMMARY.md`
</output>
