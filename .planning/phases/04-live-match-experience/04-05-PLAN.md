---
phase: 04-live-match-experience
plan: "05"
type: execute
wave: 3
depends_on: ["04-02", "04-04"]
files_modified: [
  "app/sw.ts",
  "lib/db/sync-queue.ts",
  "hooks/use-background-sync.ts"
]
autonomous: true
user_setup:
  - service: service-worker
    why: "Background Sync requires service worker registration"
    dashboard_config:
      - task: "Verify service worker is registered"
        location: "Browser DevTools -> Application -> Service Workers"

must_haves:
  truths:
    - "Events recorded offline are queued in IndexedDB"
    - "Background Sync triggers automatic upload when online"
    - "Multiple pending events sync in correct order"
    - "Sync failures retry automatically"
    - "UI shows pending sync count and status"
  artifacts:
    - path: "app/sw.ts"
      provides: "Service worker with sync event handler"
      contains: ["self.addEventListener('sync')", "syncPendingEvents()"]
    - path: "lib/db/sync-queue.ts"
      provides: "Sync queue management"
      exports: ["queueForSync", "getQueuedEvents", "removeFromQueue"]
    - path: "hooks/use-background-sync.ts"
      provides: "React hook for sync status"
      contains: ["pendingCount", "syncStatus", "isSyncing"]
  key_links:
    - from: "lib/db/match-events.ts"
      to: "lib/db/sync-queue.ts"
      via: "queueForSync on offline"
      pattern: "if (!navigator.onLine) await queueForSync(event)"
    - from: "Service Worker"
      to: "Background Sync API"
      via: "sync event"
      pattern: "registration.sync.register('match-events')"
    - from: "useBackgroundSync hook"
      to: "Service Worker messages"
      via: "navigator.serviceWorker.addEventListener('message')"
---

<objective>
Implement offline event recording with Background Sync API for automatic sync when reconnected.

Purpose: Enable match recording to continue without connectivity, with reliable automatic synchronization.
Output: Enhanced service worker with sync handlers, sync queue management, and React hook for sync status.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-live-match-experience/04-RESEARCH.md (Pattern 3: Background Sync, Pitfall #3)
@app/sw.ts (Existing service worker from Phase 1)
@lib/db/actions.ts (Existing offline action queue patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync queue management module</name>
  <files>lib/db/sync-queue.ts</files>
  <action>
    Create lib/db/sync-queue.ts for managing the Background Sync queue:

    1. Type definitions:
       ```typescript
       export interface QueuedEvent {
         id: string;              // UUID of the queued item
         eventId: string;         // Original match event ID
         matchId: string;
         table: 'match_events' | 'match_timers';
         data: Record<string, unknown>;
         queuedAt: string;        // ISO timestamp
         retryCount: number;
         lastError?: string;
       }
       ```

    2. IndexedDB store setup:
       - Add 'sync_queue' store to CalcettoDB schema
       - Key: id (string)
       - Indexes: by-match-id, by-queued-at, by-retry-count
       - Update DB_VERSION to 4 in lib/db/index.ts

    3. Core functions:
       ```typescript
       export async function queueForSync(
         table: 'match_events' | 'match_timers',
         data: Record<string, unknown>
       ): Promise<void>
       ```
       - Generate queue ID
       - Store in IndexedDB sync_queue
       - Register Background Sync if available

       ```typescript
       export async function getQueuedEvents(
         matchId?: string
       ): Promise<QueuedEvent[]>
       ```
       - Get all queued events, optionally filtered by match
       - Sort by queuedAt ascending (oldest first)

       ```typescript
       export async function removeFromQueue(queueId: string): Promise<void>
       ```
       - Delete item from sync_queue

       ```typescript
       export async function updateQueueItem(
         queueId: string,
         updates: Partial<QueuedEvent>
       ): Promise<void>
       ```
       - Update retry count, last error, etc.

       ```typescript
       export async function clearQueueForMatch(matchId: string): Promise<void>
       ```
       - Remove all queued items for a match (after successful sync)

    4. Background Sync registration:
       ```typescript
       export async function registerBackgroundSync(
         tag: string
       ): Promise<boolean>
       ```
       - Check 'sync' in ServiceWorkerRegistration.prototype
       - Get service worker registration
       - Call registration.sync.register(tag)
       - Return success/failure

    5. Queue processing:
       ```typescript
       export async function processQueue(): Promise<{
         processed: number;
         failed: number;
         errors: Error[];
       }>
       ```
       - Get all queued events
       - Process each event in order
       - On success: remove from queue
       - On failure: increment retry count, store error
       - Return summary statistics
  </action>
  <verify>Module exports queueForSync, getQueuedEvents, removeFromQueue, processQueue</verify>
  <done>Sync queue management with IndexedDB storage</done>
</task>

<task type="auto">
  <name>Task 2: Add Background Sync handler to service worker</name>
  <files>app/sw.ts</files>
  <action>
    Update app/sw.ts with Background Sync event handlers:

    1. Add sync event listener:
       ```typescript
       self.addEventListener('sync', (event) => {
         console.log('[SW] Sync event received:', event.tag);
         
         if (event.tag === 'match-events') {
           event.waitUntil(syncPendingEvents());
         } else if (event.tag.startsWith('match-event-')) {
           // Match-specific sync tag
           const matchId = event.tag.replace('match-event-', '');
           event.waitUntil(syncPendingEventsForMatch(matchId));
         }
       });
       ```

    2. Implement syncPendingEvents:
       ```typescript
       async function syncPendingEvents(): Promise<void> {
         // Open IndexedDB connection
         const db = await openDB('calcetto-db', 4);
         const queued = await db.getAll('sync_queue');
         
         if (queued.length === 0) return;
         
         console.log(`[SW] Syncing ${queued.length} pending events`);
         
         for (const item of queued) {
           try {
             const success = await syncEvent(item);
             if (success) {
               await db.delete('sync_queue', item.id);
             } else {
               await updateRetryCount(db, item);
             }
           } catch (error) {
             console.error('[SW] Sync failed for item:', item.id, error);
             await updateRetryCount(db, item, error.message);
           }
         }
         
         // Notify clients of sync completion
         await notifyClients('SYNC_COMPLETE', { processed: queued.length });
       }
       ```

    3. Implement syncEvent helper:
       ```typescript
       async function syncEvent(item: QueuedEvent): Promise<boolean> {
         const supabaseUrl = self.location.origin; // Or from env
         const supabaseKey = /* get from somewhere - perhaps embedded at build time */;
         
         const response = await fetch(`${supabaseUrl}/rest/v1/${item.table}`, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'apikey': supabaseKey,
             'Authorization': `Bearer ${await getAuthToken()}`
           },
           body: JSON.stringify(item.data)
         });
         
         return response.ok;
       }
       ```

    4. Handle auth token:
       - Store auth token in IndexedDB when user logs in
       - Service worker retrieves it for API calls
       - Clear token on logout

    5. Retry logic:
       - Exponential backoff: retryCount^2 * 1000ms
       - Max retry count: 10 attempts
       - After max retries: mark as permanent failure, notify client

    6. Client notification:
       ```typescript
       async function notifyClients(type: string, data: unknown): Promise<void> {
         const clients = await self.clients.matchAll();
         clients.forEach(client => {
           client.postMessage({ type, data });
         });
       }
       ```

    7. Periodic sync (optional enhancement):
       ```typescript
       self.addEventListener('periodicsync', (event) => {
         if (event.tag === 'match-sync') {
           event.waitUntil(syncPendingEvents());
         }
       });
       ```
  </action>
  <verify>Service worker has sync event handler, syncPendingEvents function, client notification</verify>
  <done>Service worker Background Sync handler for offline event sync</done>
</task>

<task type="auto">
  <name>Task 3: Create background sync React hook</name>
  <files>hooks/use-background-sync.ts</files>
  <action>
    Create hooks/use-background-sync.ts for monitoring sync status:

    1. Hook signature:
       ```typescript
       export interface SyncStatus {
         pendingCount: number;
         isSyncing: boolean;
         lastSyncAt: Date | null;
         lastError: string | null;
         isOnline: boolean;
       }

       export function useBackgroundSync(matchId?: string) {
         const [status, setStatus] = useState<SyncStatus>({
           pendingCount: 0,
           isSyncing: false,
           lastSyncAt: null,
           lastError: null,
           isOnline: navigator.onLine
         });
         
         return {
           ...status,
           syncNow: () => Promise<void>,
           isSupported: 'serviceWorker' in navigator && 'SyncManager' in window
         };
       }
       ```

    2. Online/offline detection:
       - Listen for 'online' and 'offline' events on window
       - Update isOnline state
       - Trigger sync check when coming back online

    3. Service worker message handling:
       ```typescript
       useEffect(() => {
         if (!('serviceWorker' in navigator)) return;
         
         const handleMessage = (event: MessageEvent) => {
           if (event.data.type === 'SYNC_COMPLETE') {
             setStatus(prev => ({
               ...prev,
               isSyncing: false,
               lastSyncAt: new Date(),
               pendingCount: Math.max(0, prev.pendingCount - event.data.data.processed)
             }));
             toast.success(`${event.data.data.processed} events synced`);
           } else if (event.data.type === 'SYNC_ERROR') {
             setStatus(prev => ({
               ...prev,
               isSyncing: false,
               lastError: event.data.data.error
             }));
           }
         };
         
         navigator.serviceWorker.addEventListener('message', handleMessage);
         return () => navigator.serviceWorker.removeEventListener('message', handleMessage);
       }, []);
       ```

    4. Pending count polling:
       - Poll IndexedDB sync_queue every 5 seconds for count
       - Update pendingCount state
       - Use matchId filter if provided

    5. Manual sync trigger:
       ```typescript
       const syncNow = useCallback(async () => {
         if (!('serviceWorker' in navigator)) return;
         
         setStatus(prev => ({ ...prev, isSyncing: true }));
         
         try {
           const registration = await navigator.serviceWorker.ready;
           await registration.sync.register('match-events');
         } catch (error) {
           setStatus(prev => ({
             ...prev,
             isSyncing: false,
             lastError: error.message
           }));
         }
       }, []);
       ```

    6. UI indicators:
       - Return helper booleans: hasPending, showSyncButton
       - Format lastSyncAt as relative time ("2 min ago")
       - Determine sync health status

    7. Integration with match events:
       - Export useMatchSync hook that combines useMatchEvents + useBackgroundSync
       - Automatically sync when events are recorded offline
       - Show sync status in event recorder UI
  </action>
  <verify>Hook tracks pending count, sync state, provides syncNow function</verify>
  <done>Background sync React hook with status monitoring</done>
</task>

</tasks>

<verification>
- Events recorded offline appear in queue immediately
- Background Sync triggers when connection restored
- Multiple queued events sync in order
- Failed syncs retry with exponential backoff
- UI shows pending count and sync status
- Service worker receives sync events and processes queue
</verification>

<success_criteria>
1. lib/db/sync-queue.ts exists with queue management functions
2. app/sw.ts has sync event handler with syncPendingEvents
3. hooks/use-background-sync.ts exists with status monitoring
4. Offline events queued in IndexedDB
5. Sync triggers automatically when online
6. Clients notified of sync completion via postMessage
</success_criteria>

<output>
After completion, create `.planning/phases/04-live-match-experience/04-05-SUMMARY.md`
</output>
