---
phase: 07-dashboard-leaderboards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/player-evolution.ts
  - hooks/use-player-evolution.ts
  - components/dashboard/player-evolution-chart.tsx
  - app/[locale]/teams/[teamId]/players/[playerId]/player-profile-client.tsx
  - messages/it.json
  - messages/en.json
autonomous: false

must_haves:
  truths:
    - "User can view player evolution chart showing goals, assists, and rating over time"
    - "Chart shows at least 2 data points for meaningful visualization"
    - "Each metric is displayed as a separate line with distinct color"
    - "Evolution chart appears on player profile page"
  artifacts:
    - path: "lib/db/player-evolution.ts"
      provides: "Evolution data aggregation"
      exports: ["getPlayerEvolution", "type EvolutionDataPoint"]
    - path: "hooks/use-player-evolution.ts"
      provides: "React hook for evolution data"
      exports: ["usePlayerEvolution"]
    - path: "components/dashboard/player-evolution-chart.tsx"
      provides: "Multi-line Rechart visualization"
      exports: ["PlayerEvolutionChart"]
    - path: "app/[locale]/teams/[teamId]/players/[playerId]/player-profile-client.tsx"
      provides: "Player profile with evolution chart"
      contains: "PlayerEvolutionChart"
  key_links:
    - from: "hooks/use-player-evolution.ts"
      to: "lib/db/player-evolution.ts"
      via: "server action import"
      pattern: "getPlayerEvolution"
    - from: "components/dashboard/player-evolution-chart.tsx"
      to: "hooks/use-player-evolution.ts"
      via: "usePlayerEvolution hook"
      pattern: "usePlayerEvolution.*playerId"
    - from: "player-profile-client.tsx"
      to: "PlayerEvolutionChart"
      via: "component import"
      pattern: "PlayerEvolutionChart.*data"
---

<objective>
Add player evolution charts showing goals, assists, and rating trends over time.

Purpose: Enable users to visualize player performance trends (DASH-08).
Output: Evolution data function, React hook, PlayerEvolutionChart component, integrated into player profile.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@lib/db/player-ratings.ts
@hooks/use-rating-history.ts
@components/ratings/rating-trend-chart.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create player evolution data aggregation function</name>
  <files>lib/db/player-evolution.ts</files>
  <action>
Create a new file for player evolution data following the player-ratings.ts pattern.

```typescript
'use server'

import { prisma } from '@/lib/db'
import { MatchStatus } from '@prisma/client'

export interface EvolutionDataPoint {
  match_id: string
  match_date: string  // Formatted date for chart display
  match_label: string  // Short label (e.g., "15 Gen")
  goals: number
  assists: number
  rating: number | null
  rating_display?: string
}

/**
 * Get player evolution data for chart visualization
 * Aggregates goals, assists, and rating per match
 * 
 * @param playerId - Player ID
 * @param teamId - Team ID to filter matches
 * @param limit - Maximum number of matches to include (default 10)
 * @returns Array of evolution data points ordered chronologically
 */
export async function getPlayerEvolution(
  playerId: string,
  teamId: string,
  limit: number = 10
): Promise<EvolutionDataPoint[]> {
  // Get all matches where player participated (has a formation position with side)
  const positions = await prisma.formationPosition.findMany({
    where: {
      playerId,
      formation: {
        match: {
          teamId,
          status: MatchStatus.COMPLETED,
        },
      },
      side: { not: null },
    },
    include: {
      formation: {
        include: {
          match: {
            select: {
              id: true,
              scheduledAt: true,
            },
          },
        },
      },
    },
    orderBy: {
      formation: {
        match: {
          scheduledAt: 'asc',
        },
      },
    },
    take: limit,
  })

  if (positions.length === 0) return []

  // Get match IDs for parallel queries
  const matchIds = positions.map(p => p.formation.matchId)

  // Get goals for each match (scored by player, excluding own goals)
  const goalsByMatch = await prisma.goal.groupBy({
    by: ['matchId'],
    where: {
      matchId: { in: matchIds },
      scorerId: playerId,
      isOwnGoal: false,
    },
    _count: true,
  })
  const goalsMap = new Map(goalsByMatch.map(g => [g.matchId, g._count]))

  // Get assists for each match
  const assistsByMatch = await prisma.goal.groupBy({
    by: ['matchId'],
    where: {
      matchId: { in: matchIds },
      assisterId: playerId,
    },
    _count: true,
  })
  const assistsMap = new Map(assistsByMatch.map(a => [a.matchId, a._count]))

  // Get ratings for each match
  const ratings = await prisma.playerRating.findMany({
    where: {
      playerId,
      matchId: { in: matchIds },
    },
    select: {
      matchId: true,
      rating: true,
    },
  })
  const ratingsMap = new Map(ratings.map(r => [r.matchId, r.rating.toNumber()]))

  // Import decimalToRating for display
  const { decimalToRating } = await import('@/lib/rating-utils')

  // Build evolution data
  return positions.map(p => {
    const match = p.formation.match
    const date = match.scheduledAt
    const rating = ratingsMap.get(match.id) ?? null

    return {
      match_id: match.id,
      match_date: date.toISOString(),
      match_label: new Intl.DateTimeFormat('it-IT', {
        day: 'numeric',
        month: 'short'
      }).format(date),
      goals: goalsMap.get(match.id)?._count ?? 0,
      assists: assistsMap.get(match.id)?._count ?? 0,
      rating,
      rating_display: rating !== null ? decimalToRating(rating) : undefined,
    }
  })
}
```

Design notes:
- Returns goals, assists, and rating per match (3 metrics)
- Ordered chronologically for trend visualization
- Follows getPlayerRatingHistory pattern
  </action>
  <verify>
    - `ls lib/db/player-evolution.ts` file exists
    - `grep "getPlayerEvolution" lib/db/player-evolution.ts` shows exported function
    - `grep "EvolutionDataPoint" lib/db/player-evolution.ts` shows interface
  </verify>
  <done>
lib/db/player-evolution.ts exports getPlayerEvolution function that aggregates goals, assists, and rating per match for a player.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create usePlayerEvolution hook</name>
  <files>hooks/use-player-evolution.ts</files>
  <action>
Create a React hook following the use-rating-history.ts pattern.

```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { getPlayerEvolution, type EvolutionDataPoint } from '@/lib/db/player-evolution'

interface UsePlayerEvolutionReturn {
  evolution: EvolutionDataPoint[]
  isLoading: boolean
  error: string | null
  refresh: () => Promise<void>
}

export function usePlayerEvolution(
  playerId: string | null,
  teamId: string | null,
  limit: number = 10
): UsePlayerEvolutionReturn {
  const [evolution, setEvolution] = useState<EvolutionDataPoint[]>([])
  const [isLoading, setIsLoading] = useState(!!playerId && !!teamId)
  const [error, setError] = useState<string | null>(null)

  const fetchEvolution = useCallback(async () => {
    if (!playerId || !teamId) {
      setEvolution([])
      setIsLoading(false)
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const result = await getPlayerEvolution(playerId, teamId, limit)
      setEvolution(result)
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : 'Errore nel caricamento dei dati evolutivi'
      setError(errorMsg)
      console.error('[usePlayerEvolution] Fetch error:', err)
    } finally {
      setIsLoading(false)
    }
  }, [playerId, teamId, limit])

  useEffect(() => {
    fetchEvolution()
  }, [fetchEvolution])

  return { evolution, isLoading, error, refresh: fetchEvolution }
}
```
  </action>
  <verify>
    - `ls hooks/use-player-evolution.ts` file exists
    - `grep "usePlayerEvolution" hooks/use-player-evolution.ts` shows exported hook
    - `grep "getPlayerEvolution" hooks/use-player-evolution.ts` shows import
  </verify>
  <done>
hooks/use-player-evolution.ts exports usePlayerEvolution hook with evolution, isLoading, error, and refresh states.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PlayerEvolutionChart component</name>
  <files>components/dashboard/player-evolution-chart.tsx</files>
  <action>
Create a multi-line chart component following the RatingTrendChart pattern.

```typescript
'use client'

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from 'recharts'
import { TrendingUp } from 'lucide-react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import type { EvolutionDataPoint } from '@/lib/db/player-evolution'

interface PlayerEvolutionChartProps {
  data: EvolutionDataPoint[]
  title?: string
}

function CustomTooltip({ active, payload }: {
  active?: boolean
  payload?: Array<{ dataKey: string; value: number; payload: EvolutionDataPoint }>
}) {
  if (!active || !payload?.length) return null

  const data = payload[0].payload
  return (
    <div className="bg-card border border-border rounded-lg p-3 shadow-lg">
      <p className="text-sm text-muted-foreground mb-2">{data.match_label}</p>
      <div className="space-y-1">
        {payload.map((entry, i) => (
          <p key={i} className="text-sm">
            <span className="font-medium capitalize">{entry.dataKey}:</span>{' '}
            {entry.dataKey === 'rating' && data.rating_display
              ? data.rating_display
              : entry.value}
          </p>
        ))}
      </div>
    </div>
  )
}

export function PlayerEvolutionChart({ data, title }: PlayerEvolutionChartProps) {
  // Need at least 2 data points for meaningful trend
  if (data.length < 2) {
    return null
  }

  return (
    <Card>
      {title && (
        <CardHeader className="pb-2">
          <CardTitle className="text-base flex items-center gap-2">
            <TrendingUp className="h-4 w-4" />
            {title}
          </CardTitle>
        </CardHeader>
      )}
      <CardContent className="pt-2">
        <ResponsiveContainer
          width="100%"
          height={250}
          initialDimension={{ width: 300, height: 250 }}
        >
          <LineChart
            data={data}
            margin={{ top: 10, right: 10, left: -10, bottom: 0 }}
          >
            <CartesianGrid strokeDasharray="3 3" opacity={0.3} />
            <XAxis
              dataKey="match_label"
              tick={{ fontSize: 10 }}
              tickLine={false}
              axisLine={false}
            />
            <YAxis
              tick={{ fontSize: 10 }}
              tickLine={false}
              axisLine={false}
            />
            <Tooltip content={<CustomTooltip />} />
            <Legend />
            <Line
              type="monotone"
              dataKey="goals"
              stroke="#ef4444"
              strokeWidth={2}
              dot={{ r: 3, fill: '#ef4444' }}
              name="Gol"
            />
            <Line
              type="monotone"
              dataKey="assists"
              stroke="#3b82f6"
              strokeWidth={2}
              dot={{ r: 3, fill: '#3b82f6' }}
              name="Assist"
            />
            <Line
              type="monotone"
              dataKey="rating"
              stroke="#eab308"
              strokeWidth={2}
              dot={{ r: 3, fill: '#eab308' }}
              name="Voto"
              connectNulls
            />
          </LineChart>
        </ResponsiveContainer>
      </CardContent>
    </Card>
  )
}
```

Design notes:
- 3 lines with distinct colors: goals (red), assists (blue), rating (yellow)
- Legend shows all 3 metrics
- Custom tooltip shows all values
- Returns null if < 2 data points (same pattern as RatingTrendChart)
- Uses ResponsiveContainer with initialDimension to prevent width warning
  </action>
  <verify>
    - `ls components/dashboard/player-evolution-chart.tsx` file exists
    - `grep "LineChart" components/dashboard/player-evolution-chart.tsx` shows Recharts usage
    - `grep "goals.*assists.*rating" components/dashboard/player-evolution-chart.tsx` shows 3 lines
    - `grep "data.length < 2" components/dashboard/player-evolution-chart.tsx` shows minimum check
  </verify>
  <done>
PlayerEvolutionChart component renders a multi-line Recharts chart with goals, assists, and rating lines. Returns null for < 2 data points.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add PlayerEvolutionChart to player profile</name>
  <files>app/[locale]/teams/[teamId]/players/[playerId]/player-profile-client.tsx</files>
  <action>
Integrate PlayerEvolutionChart into the player profile page, below the rating history section.

1. Import usePlayerEvolution hook and PlayerEvolutionChart component
2. Fetch evolution data
3. Add chart section after rating history

```typescript
import { usePlayerEvolution } from '@/hooks/use-player-evolution'
import { PlayerEvolutionChart } from '@/components/dashboard/player-evolution-chart'

// In component:
const { evolution, isLoading: evolutionLoading } = usePlayerEvolution(playerId, teamId)

// Add after Rating History section:
{/* Player Evolution Section */}
<h2 className="text-lg font-semibold mt-6 mb-3 flex items-center gap-2">
  <TrendingUp className="h-5 w-5" />
  {t('evolution.title')}
</h2>

{evolutionLoading && (
  <Card>
    <CardContent className="p-6">
      <div className="flex items-center justify-center">
        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
      </div>
    </CardContent>
  </Card>
)}

{!evolutionLoading && evolution.length >= 2 && (
  <PlayerEvolutionChart 
    data={evolution} 
    title={t('evolution.chart_title')} 
  />
)}

{!evolutionLoading && evolution.length < 2 && (
  <Card className="border-dashed">
    <CardContent className="p-6 text-center">
      <p className="text-muted-foreground">{t('evolution.no_data')}</p>
    </CardContent>
  </Card>
)}
```

Note: The chart will show 2+ data points (returns null for fewer). Show empty state for < 2 matches.
  </action>
  <verify>
    - `grep "usePlayerEvolution" app/[locale]/teams/[teamId]/players/[playerId]/player-profile-client.tsx` shows hook usage
    - `grep "PlayerEvolutionChart" app/[locale]/teams/[teamId]/players/[playerId]/player-profile-client.tsx` shows component usage
  </verify>
  <done>
Player profile displays PlayerEvolutionChart with goals/assists/rating trends when 2+ matches exist.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add translations for evolution chart</name>
  <files>messages/it.json, messages/en.json</files>
  <action>
Add translation keys for evolution feature in both Italian and English.

Under `dashboard.evolution` namespace (or `statistics.evolution` if that's where player profile translations are):
- `title`: "Evoluzione" / "Evolution"
- `chart_title`: "Andamento prestazioni" / "Performance Trend"
- `no_data`: "Servono almeno 2 partite per il grafico" / "Need at least 2 matches for chart"
- `goals`: "Gol" / "Goals"
- `assists`: "Assist" / "Assists"
- `rating`: "Voto" / "Rating"
  </action>
  <verify>
    - `grep "evolution" messages/it.json` shows all evolution keys
    - `grep "evolution" messages/en.json` shows all evolution keys
  </verify>
  <done>
Both translation files contain evolution namespace with title, chart_title, no_data, goals, assists, and rating keys.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify Player Evolution Chart</name>
  <what-built>
Player Evolution Chart feature:
1. lib/db/player-evolution.ts - Data aggregation for goals/assists/rating per match
2. hooks/use-player-evolution.ts - React hook for fetching evolution data
3. components/dashboard/player-evolution-chart.tsx - Multi-line Recharts component
4. Integration into player profile page
  </what-built>
  <how-to-verify>
1. Navigate to a player profile: `/[locale]/teams/[teamId]/players/[playerId]`

2. Verify "Evolution" section appears after rating history

3. If player has 2+ completed matches:
   - Chart should display with 3 colored lines
   - Red line = Goals
   - Blue line = Assists  
   - Yellow line = Rating
   - Legend should show all 3 metrics
   - Hover tooltip should show values

4. If player has < 2 completed matches:
   - Empty state card should show with message

5. Switch language (IT/EN) to verify translations work
  </how-to-verify>
  <resume-signal>Type "approved" if the chart works correctly, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- getPlayerEvolution aggregates goals, assists, and rating per match
- usePlayerEvolution hook fetches and manages evolution state
- PlayerEvolutionChart renders 3-line chart with proper colors
- Player profile displays the chart when 2+ matches exist
- Translations exist for all evolution-related text
- Human verification confirms chart works correctly
</verification>

<success_criteria>
- DASH-08: Player evolution charts display with goals/assists/rating trends over time
- Chart shows 3 distinct colored lines
- Chart only appears when 2+ data points exist
- Works in both Italian and English
</success_criteria>

<output>
After completion, create `.planning/phases/07-dashboard-leaderboards/07-01-SUMMARY.md`
</output>
