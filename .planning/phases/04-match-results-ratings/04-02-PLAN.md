---
phase: 04-match-results-ratings
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified: [
  "lib/db/match-lifecycle.ts",
  "lib/validations/match-lifecycle.ts",
  "hooks/use-match-lifecycle.ts",
  "components/matches/match-status-badge.tsx",
  "components/matches/match-lifecycle-buttons.tsx"
]
autonomous: true

must_haves:
  truths:
    - "Admin can start a match (scheduled → in_progress)"
    - "Admin can end a match (in_progress → finished)"
    - "Admin can complete a match (finished → completed)"
    - "Admin can input final results directly (scheduled → finished)"
    - "Status badge shows current match state with correct colors"
  artifacts:
    - path: "lib/db/match-lifecycle.ts"
      provides: "startMatch, endMatch, completeMatch, inputFinalResults functions"
      exports: ["startMatch", "endMatch", "completeMatch", "inputFinalResults"]
    - path: "components/matches/match-lifecycle-buttons.tsx"
      provides: "UI for Start Match, End Match, Complete Match, Final Results buttons"
    - path: "components/matches/match-status-badge.tsx"
      provides: "Visual status indicator"
  key_links:
    - from: "match-lifecycle-buttons.tsx"
      to: "lib/db/match-lifecycle.ts"
      via: "server actions"
      pattern: "startMatch|endMatch|completeMatch"
---

<objective>
Implement match lifecycle transitions: Start Match, End Match, Complete Match, and Final Results flow.

Purpose: Enable admin to control match state transitions with proper validation and UI.
Output: Server actions for lifecycle, React hooks, status badge, lifecycle button components.
</objective>

<execution_context>
@/home/ubuntu/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/ubuntu/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-live-match-experience/04-CONTEXT.md
@.planning/phases/04-live-match-experience/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create match lifecycle server actions</name>
  <files>lib/db/match-lifecycle.ts</files>
  <action>
    Create lib/db/match-lifecycle.ts with the following server actions:
    
    ```typescript
    'use server'
    
    import { auth } from '@/lib/auth'
    import { prisma } from '@/lib/db'
    import { MatchStatus } from '@prisma/client'
    
    // Check if user is team admin or co-admin
    async function isTeamAdmin(teamId: string, userId: string): Promise<boolean>
    
    // Start match: scheduled → in_progress
    export async function startMatch(matchId: string): Promise<Match>
    
    // End match: in_progress → finished  
    export async function endMatch(matchId: string): Promise<Match>
    
    // Complete match: finished → completed (locks all edits)
    export async function completeMatch(matchId: string): Promise<Match>
    
    // Final Results: scheduled → finished (skip in_progress)
    export async function inputFinalResults(
      matchId: string,
      homeScore: number,
      awayScore: number
    ): Promise<Match>
    ```
    
    Each function should:
    - Verify user authentication
    - Check user is team admin/co-admin
    - Validate current status allows transition
    - Update match status
    - Return updated match
    
    Transitions:
    - startMatch: SCHEDULED → IN_PROGRESS
    - endMatch: IN_PROGRESS → FINISHED
    - completeMatch: FINISHED → COMPLETED
    - inputFinalResults: SCHEDULED → FINISHED (also sets scores)
  </action>
  <verify>npm run build passes</verify>
  <done>All 4 lifecycle functions exist with proper validation</done>
</task>

<task type="auto">
  <name>Task 2: Create validation schemas</name>
  <files>lib/validations/match-lifecycle.ts</files>
  <action>
    Create lib/validations/match-lifecycle.ts with Zod schemas:
    
    ```typescript
    import { z } from 'zod'
    
    export const startMatchSchema = z.object({
      matchId: z.string().cuid(),
    })
    
    export const endMatchSchema = z.object({
      matchId: z.string().cuid(),
    })
    
    export const completeMatchSchema = z.object({
      matchId: z.string().cuid(),
    })
    
    export const inputFinalResultsSchema = z.object({
      matchId: z.string().cuid(),
      homeScore: z.number().int().min(0).max(99),
      awayScore: z.number().int().min(0).max(99),
    })
    ```
  </action>
  <verify>npm run build passes</verify>
  <done>Zod schemas for all lifecycle actions</done>
</task>

<task type="auto">
  <name>Task 3: Create useMatchLifecycle hook</name>
  <files>hooks/use-match-lifecycle.ts</files>
  <action>
    Create hooks/use-match-lifecycle.ts:
    
    ```typescript
    'use client'
    
    import { useState } from 'react'
    import { useRouter } from 'next/navigation'
    import { startMatch, endMatch, completeMatch, inputFinalResults } from '@/lib/db/match-lifecycle'
    import { useToast } from '@/hooks/use-toast'
    
    export function useMatchLifecycle(matchId: string, teamId: string) {
      const [isLoading, setIsLoading] = useState(false)
      const router = useRouter()
      const { toast } = useToast()
      
      const handleStartMatch = async () => { ... }
      const handleEndMatch = async () => { ... }
      const handleCompleteMatch = async () => { ... }
      const handleInputFinalResults = async (homeScore: number, awayScore: number) => { ... }
      
      return {
        isLoading,
        startMatch: handleStartMatch,
        endMatch: handleEndMatch,
        completeMatch: handleCompleteMatch,
        inputFinalResults: handleInputFinalResults,
      }
    }
    ```
    
    Include optimistic updates and error handling with toast notifications.
    Use Italian messages from existing patterns.
  </action>
  <verify>npm run build passes</verify>
  <done>Hook exports startMatch, endMatch, completeMatch, inputFinalResults</done>
</task>

<task type="auto">
  <name>Task 4: Create MatchStatusBadge component</name>
  <files>components/matches/match-status-badge.tsx</files>
  <action>
    Create components/matches/match-status-badge.tsx:
    
    ```typescript
    'use client'
    
    import { MatchStatus } from '@prisma/client'
    import { Badge } from '@/components/ui/badge'
    
    const statusConfig = {
      SCHEDULED: { label: 'Programmata', variant: 'secondary' },
      IN_PROGRESS: { label: 'In corso', variant: 'default' },
      FINISHED: { label: 'Terminata', variant: 'outline' },
      COMPLETED: { label: 'Completata', variant: 'success' },
      CANCELLED: { label: 'Cancellata', variant: 'destructive' },
    }
    
    interface MatchStatusBadgeProps {
      status: MatchStatus
    }
    
    export function MatchStatusBadge({ status }: MatchStatusBadgeProps)
    ```
    
    Use shadcn/ui Badge component with appropriate variants.
    Color coding: scheduled (gray), in_progress (blue), finished (yellow), completed (green), cancelled (red).
  </action>
  <verify>npm run build passes</verify>
  <done>Badge component shows correct label and color per status</done>
</task>

<task type="auto">
  <name>Task 5: Create MatchLifecycleButtons component</name>
  <files>components/matches/match-lifecycle-buttons.tsx</files>
  <action>
    Create components/matches/match-lifecycle-buttons.tsx:
    
    This component shows different buttons based on match status:
    - SCHEDULED: Show "Start Match" (primary) and "Final Results" (secondary) buttons
    - IN_PROGRESS: Show "End Match" button
    - FINISHED: Show "Complete Match" button
    - COMPLETED: Show nothing (read-only)
    
    ```typescript
    'use client'
    
    import { MatchStatus } from '@prisma/client'
    import { Button } from '@/components/ui/button'
    import { useMatchLifecycle } from '@/hooks/use-match-lifecycle'
    import { AlertDialog, AlertDialogTrigger, AlertDialogContent, ... } from '@/components/ui/alert-dialog'
    
    interface MatchLifecycleButtonsProps {
      matchId: string
      teamId: string
      status: MatchStatus
      isAdmin: boolean
    }
    
    export function MatchLifecycleButtons({ matchId, teamId, status, isAdmin }: MatchLifecycleButtonsProps)
    ```
    
    Include confirmation dialogs for destructive actions.
    Only show buttons if isAdmin is true.
    Final Results should open a dialog to input homeScore and awayScore.
  </action>
  <verify>npm run build passes</verify>
  <done>Buttons show correct actions per status, admin-only, with confirmations</done>
</task>

</tasks>

<verification>
- [ ] startMatch transitions SCHEDULED → IN_PROGRESS
- [ ] endMatch transitions IN_PROGRESS → FINISHED
- [ ] completeMatch transitions FINISHED → COMPLETED
- [ ] inputFinalResults transitions SCHEDULED → FINISHED with scores
- [ ] All actions verify user is team admin
- [ ] Status badge shows correct Italian labels and colors
- [ ] Lifecycle buttons show correct options per status
- [ ] Confirmation dialogs on important actions
</verification>

<success_criteria>
Admin can control match lifecycle:
- Start Match button works (scheduled → in_progress)
- End Match button works (in_progress → finished)
- Complete Match button works (finished → completed, locks edits)
- Final Results button works (scheduled → finished, sets scores)
- Status badge correctly displays current state
</success_criteria>

<output>
After completion, create `.planning/phases/04-match-results-ratings/04-02-SUMMARY.md`
</output>
