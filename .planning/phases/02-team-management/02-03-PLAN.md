---
phase: 02-team-management
plan: 03
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - lib/db/players.ts
  - lib/validations/player.ts
  - components/players/player-form.tsx
  - components/players/player-card.tsx
  - components/players/avatar-cropper.tsx
  - components/players/role-selector.tsx
  - lib/image-utils.ts
  - app/[locale]/teams/[teamId]/players/page.tsx
  - messages/it.json
  - messages/en.json
autonomous: true
user_setup:
  - service: npm
    action: "Install react-easy-crop for avatar cropping"
    command: "npm install react-easy-crop"

must_haves:
  truths:
    - "User can add players with name, surname, nickname, jersey number"
    - "User can upload and crop player avatar to square format"
    - "User can assign multiple roles to players (goalkeeper, defender, midfielder, attacker)"
    - "Player form validates required fields with Italian error messages"
    - "Player list shows avatar, name, roles, and jersey number"
    - "Avatars upload to Supabase Storage after client-side crop"
  artifacts:
    - path: "lib/db/players.ts"
      provides: "Player CRUD operations"
      exports: ["createPlayer", "updatePlayer", "deletePlayer", "getPlayersByTeam"]
    - path: "lib/validations/player.ts"
      provides: "Player validation schemas"
      exports: ["createPlayerSchema", "updatePlayerSchema"]
    - path: "components/players/avatar-cropper.tsx"
      provides: "Avatar crop UI using react-easy-crop"
      exports: ["AvatarCropper"]
    - path: "components/players/role-selector.tsx"
      provides: "Multi-select role component"
      exports: ["RoleSelector"]
    - path: "components/players/player-form.tsx"
      provides: "Player creation/editing form"
      contains: ["name", "surname", "nickname", "jersey_number", "avatar", "roles"]
    - path: "lib/image-utils.ts"
      provides: "Image cropping utilities"
      exports: ["getCroppedImg"]
  key_links:
    - from: "components/players/avatar-cropper.tsx"
      to: "react-easy-crop"
      via: "Cropper component with aspect=1"
      pattern: "import Cropper from 'react-easy-crop'"
    - from: "components/players/player-form.tsx"
      to: "Supabase Storage"
      via: "upload avatar to 'avatars' bucket"
      pattern: "supabase.storage.from('avatars').upload"
    - from: "components/players/role-selector.tsx"
      to: "Player roles state"
      via: "TEXT[] array of roles"
      pattern: "roles: PlayerRole\[\]"
---

<objective>
Implement player management with avatar upload/cropping and multi-role assignment (TEAM-02, TEAM-03, TEAM-04).

Purpose: Enables team admins to add and manage players with complete profiles including photos and positions.
Output: Player CRUD operations, avatar cropping with react-easy-crop, role selector UI, and player list view.
</objective>

<execution_context>
@C:/Users/mikei/.config/opencode/get-shit-done/workflows/execute-plan.md
@C:/Users/mikei/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-team-management/02-RESEARCH.md
@lib/db/schema.ts
@lib/db/actions.ts

## Research Requirements (from 02-RESEARCH.md)
- Use react-easy-crop for avatar cropping before Supabase Storage upload
- Client-side crop to square (1:1 aspect ratio) using canvas API
- Multiple roles per player stored as TEXT[] array
- Compress JPEG to ~95% quality before upload
- 5MB limit on avatars bucket (already created in 02-01)

## Existing Patterns (from STATE.md)
- Offline-first: local write first, queue for sync
- react-hook-form + zodResolver for forms
- Italian error messages for validation
- Mobile-first: 48px+ touch targets
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-easy-crop dependency</name>
  <files>package.json</files>
  <action>
Install react-easy-crop library for avatar cropping:

```bash
npm install react-easy-crop
npm install -D @types/react-easy-crop
```

NOTE: This library provides mobile-friendly cropping with pinch-to-zoom gestures. Per RESEARCH.md, it's the most popular choice (2.7k stars) and actively maintained.
  </action>
  <verify>Check package.json includes "react-easy-crop" in dependencies</verify>
  <done>react-easy-crop installed and ready for use</done>
</task>

<task type="auto">
  <name>Task 2: Create image cropping utilities</name>
  <files>lib/image-utils.ts</files>
  <action>
Create client-side image cropping utility per RESEARCH.md pattern:

```typescript
/**
 * Image cropping utilities for avatar upload
 * Uses Canvas API for client-side processing
 */

export interface CropArea {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * Crop an image to the specified area and return as Blob
 * @param imageSrc - Source image URL (from FileReader)
  * @param pixelCrop - Crop coordinates from react-easy-crop
 * @returns Promise<Blob> - Cropped image as JPEG blob
 */
export function getCroppedImg(imageSrc: string, pixelCrop: CropArea): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.crossOrigin = 'anonymous';
    image.src = imageSrc;

    image.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        reject(new Error('Canvas context not available'));
        return;
      }

      // Square output (1:1 aspect ratio from cropper)
      canvas.width = pixelCrop.width;
      canvas.height = pixelCrop.height;

      ctx.drawImage(
        image,
        pixelCrop.x,
        pixelCrop.y,
        pixelCrop.width,
        pixelCrop.height,
        0,
        0,
        pixelCrop.width,
        pixelCrop.height
      );

      // Convert to JPEG with 95% quality (per research recommendation)
      canvas.toBlob(
        (blob) => {
          if (blob) resolve(blob);
          else reject(new Error('Canvas to Blob failed'));
        },
        'image/jpeg',
        0.95
      );
    };

    image.onerror = () => reject(new Error('Failed to load image'));
  });
}

/**
 * Resize image to maximum dimensions while maintaining aspect ratio
 * @param file - Input image file
 * @param maxWidth - Maximum width (default 512 for avatars)
 * @param maxHeight - Maximum height (default 512 for avatars)
 * @returns Promise<Blob> - Resized image
 */
export function resizeImage(
  file: File,
  maxWidth = 512,
  maxHeight = 512
): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        let width = img.width;
        let height = img.height;

        // Calculate new dimensions
        if (width > height) {
          if (width > maxWidth) {
            height *= maxWidth / width;
            width = maxWidth;
          }
        } else {
          if (height > maxHeight) {
            width *= maxHeight / height;
            height = maxHeight;
          }
        }

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          reject(new Error('Canvas context not available'));
          return;
        }

        ctx.drawImage(img, 0, 0, width, height);

        canvas.toBlob(
          (blob) => {
            if (blob) resolve(blob);
            else reject(new Error('Canvas to Blob failed'));
          },
          'image/jpeg',
          0.95
        );
      };
      img.onerror = reject;
      img.src = e.target?.result as string;
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}
```

NOTE: Per RESEARCH.md, resize to 512x512 max before upload to control storage costs. JPEG at 95% quality provides good compression without visible artifacts.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Image cropping and resizing utilities created with Canvas API</done>
</task>

<task type="auto">
  <name>Task 3: Create avatar cropper component</name>
  <files>components/players/avatar-cropper.tsx</files>
  <action>
Create avatar cropping component using react-easy-crop:

```typescript
'use client';

import { useState, useCallback } from 'react';
import Cropper, { type Area } from 'react-easy-crop';
import { useTranslations } from 'next-intl';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import { getCroppedImg, type CropArea } from '@/lib/image-utils';
import { Loader2 } from 'lucide-react';

interface AvatarCropperProps {
  image: string;
  onCropComplete: (croppedBlob: Blob) => void;
  onCancel: () => void;
}

export function AvatarCropper({ image, onCropComplete, onCancel }: AvatarCropperProps) {
  const t = useTranslations('players');
  const [crop, setCrop] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState<CropArea | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const onCropCompleteCallback = useCallback((_: Area, croppedPixels: Area) => {
    setCroppedAreaPixels({
      x: croppedPixels.x,
      y: croppedPixels.y,
      width: croppedPixels.width,
      height: croppedPixels.height,
    });
  }, []);

  const handleSave = async () => {
    if (!croppedAreaPixels) return;

    setIsProcessing(true);
    try {
      const croppedBlob = await getCroppedImg(image, croppedAreaPixels);
      onCropComplete(croppedBlob);
    } catch (e) {
      console.error('Crop failed:', e);
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="flex flex-col gap-4">
      <div className="relative h-64 w-full bg-muted rounded-lg overflow-hidden">
        <Cropper
          image={image}
          crop={crop}
          zoom={zoom}
          aspect={1}
          cropShape="round"
          showGrid={false}
          onCropChange={setCrop}
          onZoomChange={setZoom}
          onCropComplete={onCropCompleteCallback}
        />
      </div>

      <div className="flex items-center gap-4 px-2">
        <span className="text-sm text-muted-foreground whitespace-nowrap">
          {t('avatar.zoom')}
        </span>
        <Slider
          value={[zoom]}
          min={1}
          max={3}
          step={0.1}
          onValueChange=  {([v]) => setZoom(v)}
          className="flex-1"
        />
      </div>

      <div className="flex gap-2">
        <Button
          variant="outline"
          onClick={onCancel}
          className="flex-1 h-12"
          disabled={isProcessing}
        >
          {t('avatar.cancel')}
        </Button>
        <Button
          onClick={handleSave}
          className="flex-1 h-12"
          disabled={!croppedAreaPixels || isProcessing}
        >
          {isProcessing ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              {t('avatar.processing')}
            </>
          ) : (
            t('avatar.save')
          )}
        </Button>
      </div>
    </div>
  );
}
```

NOTE: Per RESEARCH.md, uses aspect={1} for square crop, cropShape="round" for circular preview, and zoom slider for fine-tuning. h-12 buttons for mobile touch targets.
  </action>
  <verify>Component compiles; imports resolve</verify>
  <done>Avatar cropper component with zoom slider, round crop preview, and save/cancel buttons</done>
</task>

<task type="auto">
  <name>Task 4: Create role selector component</name>
  <files>components/players/role-selector.tsx</files>
  <action>
Create multi-select role selector for player positions:

```typescript
'use client';

import { useTranslations } from 'next-intl';
import { Toggle } from '@/components/ui/toggle';
import { Shield, UserCircle, Zap, Target } from 'lucide-react';
import type { PlayerRole } from '@/lib/db/schema';

const ROLES: { id: PlayerRole; icon: typeof Shield; translationKey: string }[] = [
  { id: 'goalkeeper', icon: Shield, translationKey: 'roles.goalkeeper' },
  { id: 'defender', icon: UserCircle, translationKey: 'roles.defender' },
  { id: 'midfielder', icon: Zap, translationKey: 'roles.midfielder' },
  { id: 'attacker', icon: Target, translationKey: 'roles.attacker' },
];

interface RoleSelectorProps {
  value: PlayerRole[];
  onChange: (roles: PlayerRole[]) => void;
  disabled?: boolean;
}

export function RoleSelector({ value, onChange, disabled }: RoleSelectorProps) {
  const t = useTranslations('players');

  const toggleRole = (roleId: PlayerRole) => {
    if (disabled) return;

    if (value.includes(roleId)) {
      onChange(value.filter((r) => r !== roleId));
    } else {
      onChange([...value, roleId]);
    }
  };

  return (
    <div className="space-y-2">
      <label className="text-sm font-medium">{t('form.roles')}</label>
      <div className="flex flex-wrap gap-2">
        {ROLES.map(({ id, icon: Icon, translationKey }) => (
          <Toggle
            key={id}
            pressed={value.includes(id)}
            onPressedChange={() => toggleRole(id)}
            disabled={disabled}
            className="flex items-center gap-2 px-4 py-2 h-12 data-[state=on]:bg-primary data-[state=on]:text-primary-foreground"
            aria-label={t(translationKey)}
          >
            <Icon className="h-4 w-4" />
            <span className="text-sm">{t(translationKey)}</span>
          </Toggle>
        ))}
      </div>
      <p className="text-xs text-muted-foreground">
        {t('form.rolesHint')}
      </p>
    </div>
  );
}
```

NOTE: Allows multiple roles per player (e.g., defender AND midfielder). Uses Toggle component from shadcn/ui with pressed state. h-12 for mobile touch targets.
  </action>
  <verify>Component compiles; Toggle component available</verify>
  <done>Role selector with 4 positions (goalkeeper, defender, midfielder, attacker) as toggle buttons</done>
</task>

<task type="auto">
  <name>Task 5: Create player validation schemas</name>
  <files>lib/validations/player.ts</files>
  <action>
Create Zod validation schemas for players:

```typescript
import { z } from 'zod';
import type { PlayerRole } from '@/lib/db/schema';

export const createPlayerSchema = z.object({
  name: z
    .string()
    .min(1, 'Il nome è obbligatorio')
    .max(50, 'Il nome non può superare i 50 caratteri'),
  surname: z
    .string()
    .max(50, 'Il cognome non può superare i 50 caratteri')
    .optional()
    .or(z.literal('')),
  nickname: z
    .string()
    .max(50, 'Il nickname non può superare i 50 caratteri')
    .optional()
    .or(z.literal('')),
  jersey_number: z
    .union([
      z.number().int().min(1).max(99),
      z.string().transform((val) => (val === '' ? undefined : parseInt(val, 10))),
      z.undefined(),
    ])
    .optional()
    .refine((val) => val === undefined || (val >= 1 && val <= 99), {
      message: 'Il numero deve essere tra 1 e 99',
    }),
  roles: z.array(z.enum(['goalkeeper', 'defender', 'midfielder', 'attacker'])).default([]),
});

export const updatePlayerSchema = createPlayerSchema.partial();

export type CreatePlayerInput = z.infer<typeof createPlayerSchema>;
export type UpdatePlayerInput = z.infer<typeof updatePlayerSchema>;
```

NOTE: Name is required, surname/nickname optional. Jersey number 1-99 per football standards. Roles as array allowing multiple positions. Italian error messages.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Player validation schemas with Italian messages and proper constraints</done>
</task>

<task type="auto">
  <name>Task 6: Create player database operations</name>
  <files>lib/db/players.ts</files>
  <action>
Create player CRUD operations with offline support:

```typescript
/**
 * Player CRUD Operations with Offline Support
 */

import { getDB } from './index';
import { queueOfflineAction } from './actions';
import { createClient } from '@/lib/supabase/client';
import type { Player } from './schema';
import type { CreatePlayerInput, UpdatePlayerInput } from '@/lib/validations/player';

const supabase = createClient();

/**
 * Get players by team ID (from local DB)
 */
export async function getPlayersByTeam(teamId: string): Promise<Player[]> {
  const db = await getDB();
  const players = await db.getAllFromIndex('players', 'by-team-id', teamId);
  // Filter out soft-deleted players
  return players.filter((p) => !p.deleted_at);
}

/**
 * Get a single player by ID
 */
export async function getPlayer(id: string): Promise<Player | undefined> {
  const db = await getDB();
  const player = await db.get('players', id);
  if (player?.deleted_at) return undefined;
  return player;
}

/**
 * Upload avatar to Supabase Storage
 */
export async function uploadAvatar(
  playerId: string,
  blob: Blob
): Promise<string | null> {
  try {
    const fileName = `players/${playerId}.jpg`;
    const { error } = await supabase.storage
      .from('avatars')
      .upload(fileName, blob, {
        contentType: 'image/jpeg',
        upsert: true,
      });

    if (error) {
      console.error('Avatar upload failed:', error);
      return null;
    }

    const { data } = supabase.storage.from('avatars').getPublicUrl(fileName);
    return data.publicUrl;
  } catch (error) {
    console.error('Avatar upload error:', error);
    return null;
  }
}

/**
 * Create a new player with offline support
 */
export async function createPlayer(
  data: CreatePlayerInput,
  teamId: string,
  avatarBlob?: Blob
): Promise<Player> {
  const db = await getDB();
  const now = new Date().toISOString();
  const playerId = crypto.randomUUID();

  // Upload avatar if provided
  let avatarUrl: string | undefined;
  if (avatarBlob) {
    avatarUrl = await uploadAvatar(playerId, avatarBlob) || undefined;
  }

  // Create player object
  const player: Player = {
    id: playerId,
    team_id: teamId,
    name: data.name,
    surname: data.surname || '',
    nickname: data.nickname || undefined,
    jersey_number: data.jersey_number || undefined,
    avatar_url: avatarUrl,
    user_id: null,
    roles: data.roles,
    created_at: now,
    updated_at: now,
    deleted_at: null,
    sync_status: 'pending',
  };

  // Optimistic local write
  await db.put('players', player);

  // Queue for sync
  await queueOfflineAction('create', 'players', {
    id: playerId,
    team_id: teamId,
    name: data.name,
    surname: data.surname,
    nickname: data.nickname,
    jersey_number: data.jersey_number,
    avatar_url: avatarUrl,
    roles: data.roles,
  });

  return player;
}

/**
 * Update player (admin only)
 */
export async function updatePlayer(
  playerId: string,
  data: UpdatePlayerInput,
  avatarBlob?: Blob
): Promise<Player> {
  const db = await getDB();
  const existing = await db.get('players', playerId);

  if (!existing) {
    throw new Error('Player not found');
  }

  // Upload new avatar if provided
  let avatarUrl = existing.avatar_url;
  if (avatarBlob) {
    avatarUrl = await uploadAvatar(playerId, avatarBlob) || existing.avatar_url;
  }

  const updated: Player = {
    ...existing,
    ...data,
    avatar_url: avatarUrl,
    updated_at: new Date().toISOString(),
    sync_status: 'pending',
  };

  await db.put('players', updated);

  await queueOfflineAction('update', 'players', {
    id: playerId,
    ...data,
    avatar_url: avatarUrl,
  });

  return updated;
}

/**
 * Soft delete player (admin only)
 */
export async function deletePlayer(playerId: string): Promise<void> {
  const db = await getDB();
  const player = await db.get('players', playerId);

  if (!player) {
    throw new Error('Player not found');
  }

  const updated: Player = {
    ...player,
    deleted_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    sync_status: 'pending',
  };

  await db.put('players', updated);

  await queueOfflineAction('update', 'players', {
    id: playerId,
    deleted_at: updated.deleted_at,
  });
}
```

NOTE: Avatar upload happens before local write so URL is available. Soft delete preserves player history in matches. Follows offline-first pattern with optimistic updates.
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Player CRUD operations with avatar upload and offline support</done>
</task>

<task type="auto">
  <name>Task 7: Create player form component</name>
  <files>components/players/player-form.tsx</files>
  <action>
Create player form with avatar upload and role selection:

```typescript
'use client';

import { useState, useRef, useCallback } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useTranslations } from 'next-intl';
import { createPlayerSchema, type CreatePlayerInput } from '@/lib/validations/player';
import { AvatarCropper } from './avatar-cropper';
import { RoleSelector } from './role-selector';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { User, Upload, X } from 'lucide-react';
import Image from 'next/image';
import type { PlayerRole } from '@/lib/db/schema';

interface PlayerFormProps {
  teamId: string;
  onSubmit: (data: CreatePlayerInput, avatarBlob?: Blob) => Promise<void>;
  onCancel: () => void;
}

export function PlayerForm({ teamId, onSubmit, onCancel }: PlayerFormProps) {
  const t = useTranslations('players');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [avatarImage, setAvatarImage] = useState<string | null>(null);
  const [avatarBlob, setAvatarBlob] = useState<Blob | undefined>(undefined);
  const [showCropper, setShowCropper] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const form = useForm<CreatePlayerInput>({
    resolver: zodResolver(createPlayerSchema),
    defaultValues: {
      name: '',
      surname: '',
      nickname: '',
      jersey_number: undefined,
      roles: [],
    },
  });

  const handleFileSelect = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Validate file type and size
    if (!file.type.startsWith('image/')) {
      alert(t('avatar.errorType'));
      return;
    }
    if (file.size > 5 * 1024 * 1024) {
      alert(t('avatar.errorSize'));
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      setAvatarImage(reader.result as string);
      setShowCropper(true);
    };
    reader.readAsDataURL(file);
  }, [t]);

  const handleCropComplete = useCallback((blob: Blob) => {
    setAvatarBlob(blob);
    setShowCropper(false);
    // Create preview URL
    setAvatarImage(URL.createObjectURL(blob));
  }, []);

  const handleCropCancel = useCallback(() => {
    setShowCropper(false);
    setAvatarImage(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  }, []);

  const handleSubmit = async (data: CreatePlayerInput) => {
    setIsSubmitting(true);
    try {
      await onSubmit(data, avatarBlob);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (showCropper && avatarImage) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>{t('avatar.cropTitle')}</CardTitle>
        </CardHeader>
        <CardContent>
          <AvatarCropper
            image={avatarImage}
            onCropComplete={handleCropComplete}
            onCancel={handleCropCancel}
          />
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>{t('create.title')}</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
          {/* Avatar Upload */}
          <div className="space-y-2">
            <Label>{t('form.avatar')}</Label>
            <div className="flex items-center gap-4">
              {avatarImage ? (
                <div className="relative">
                  <Image
                    src={avatarImage}
                    alt="Avatar preview"
                    width={80}
                    height={80}
                    className="rounded-full object-cover"
                  />
                  <button
                    type="button"
                    onClick={() => {
                      setAvatarImage(null);
                      setAvatarBlob(undefined);
                      if (fileInputRef.current) {
                        fileInputRef.current.value = '';
                      }
                    }}
                    className="absolute -top-1 -right-1 bg-destructive text-destructive-foreground rounded-full p-1"
                  >
                    <X className="h-3 w-3" />
                  </button>
                </div>
              ) : (
                <div className="w-20 h-20 rounded-full bg-muted flex items-center justify-center">
                  <User className="h-8 w-8 text-muted-foreground" />
                </div>
              )}
              <div className="flex-1">
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="image/*"
                  onChange={handleFileSelect}
                  className="hidden"
                  id="avatar-input"
                />
                <Label
                  htmlFor="avatar-input"
                  className="flex items-center gap-2 cursor-pointer"
                >
                  <Button type="button" variant="outline" className="h-12" asChild>
                    <span>
                      <Upload className="mr-2 h-4 w-4" />
                      {avatarImage ? t('avatar.change') : t('avatar.upload')}
                    </span>
                  </Button>
                </Label>
                <p className="text-xs text-muted-foreground mt-2">
                  {t('avatar.hint')}
                </p>
              </div>
            </div>
          </div>

          {/* Name */}
          <div className="space-y-2">
            <Label htmlFor="name">{t('form.name')} *</Label>
            <Input
              id="name"
              {...form.register('name')}
              placeholder={t('form.namePlaceholder')}
              className="h-12"
            />
            {form.formState.errors.name && (
              <p className="text-sm text-destructive">
                {form.formState.errors.name.message}
              </p>
            )}
          </div>

          {/* Surname */}
          <div className="space-y-2">
            <Label htmlFor="surname">{t('form.surname')}</Label>
            <Input
              id="surname"
              {...form.register('surname')}
              placeholder={t('form.surnamePlaceholder')}
              className="h-12"
            />
            {form.formState.errors.surname && (
              <p className="text-sm text-destructive">
                {form.formState.errors.surname.message}
              </p>
            )}
          </div>

          {/* Nickname */}
          <div className="space-y-2">
            <Label htmlFor="nickname">{t('form.nickname')}</Label>
            <Input
              id="nickname"
              {...form.register('nickname')}
              placeholder={t('form.nicknamePlaceholder')}
              className="h-12"
            />
            {form.formState.errors.nickname && (
              <p className="text-sm text-destructive">
                {form.formState.errors.nickname.message}
              </p>
            )}
          </div>

          {/* Jersey Number */}
          <div className="space-y-2">
            <Label htmlFor="jersey_number">{t('form.jerseyNumber')}</Label>
            <Input
              id="jersey_number"
              type="number"
              min={1}
              max={99}
              {...form.register('jersey_number', { valueAsNumber: true })}
              placeholder="10"
              className="h-12"
            />
            {form.formState.errors.jersey_number && (
              <p className="text-sm text-destructive">
                {form.formState.errors.jersey_number.message}
              </p>
            )}
          </div>

          {/* Roles */}
          <RoleSelector
            value={form.watch('roles') as PlayerRole[]}
            onChange={(roles) => form.setValue('roles', roles)}
          />

          {/* Actions */}
          <div className="flex gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              className="flex-1 h-12"
              onClick={onCancel}
            >
              {t('form.cancel')}
            </Button>
            <Button
              type="submit"
              className="flex-1 h-12"
              disabled={isSubmitting}
            >
              {isSubmitting ? t('form.saving') : t('form.save')}
            </Button>
          </div>
        </form>
      </CardContent>
    </Card>
  );
}
```

NOTE: Multi-step flow: file select -> cropper -> form. Avatar preview shown after crop. All fields with Italian labels. Roles selector integrated. h-12 inputs for mobile.
  </action>
  <verify>Component compiles; all imports resolve</verify>
  <done>Player form with avatar upload, cropper integration, and role selector</done>
</task>

<task type="auto">
  <name>Task 8: Create player card and player list components</name>
  <files>
    components/players/player-card.tsx
    components/players/player-list.tsx
  </files>
  <action>
Create player card and list components:

**components/players/player-card.tsx:**
```typescript
'use client';

import Image from 'next/image';
import { useTranslations } from 'next-intl';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { User, Shirt } from 'lucide-react';
import type { Player } from '@/lib/db/schema';

interface PlayerCardProps {
  player: Player;
  onClick?: () => void;
}

export function PlayerCard({ player, onClick }: PlayerCardProps) {
  const t = useTranslations('players');

  const displayName = player.nickname || `${player.name} ${player.surname}`.trim();

  return (
    <Card
      className="cursor-pointer hover:shadow-md transition-shadow"
      onClick={onClick}
    >
      <CardContent className="p-4">
        <div className="flex items-center gap-4">
          {/* Avatar */}
          <div className="relative w-16 h-16 shrink-0">
            {player.avatar_url ? (
              <Image
                src={player.avatar_url}
                alt={displayName}
                fill
                className="rounded-full object-cover"
              />
            ) : (
              <div className="w-16 h-16 rounded-full bg-muted flex items-center justify-center">
                <User className="h-8 w-8 text-muted-foreground" />
              </div>
            )}
          </div>

          {/* Info */}
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold truncate">{displayName}</h3>
            {player.nickname && (
              <p className="text-sm text-muted-foreground">
                {player.name} {player.surname}
              </p>
            )}

            {/* Roles */}
            {player.roles.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {player.roles.map((role) => (
                  <Badge key={role} variant="secondary" className="text-xs">
                    {t(`roles.${role}`)}
                  </Badge>
                ))}
              </div>
            )}
          </div>

          {/* Jersey Number */}
          {player.jersey_number && (
            <div className="flex items-center gap-1 text-muted-foreground shrink-0">
              <Shirt className="h-4 w-4" />
              <span className="font-medium">{player.jersey_number}</span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

**components/players/player-list.tsx:**
```typescript
'use client';

import { useState } from 'react';
import { useTranslations } from 'next-intl';
import { PlayerCard } from './player-card';
import { PlayerForm } from './player-form';
import { Button } from '@/components/ui/button';
import { Plus, Users } from 'lucide-react';
import { createPlayer } from '@/lib/db/players';
import type { Player } from '@/lib/db/schema';
import type { CreatePlayerInput } from '@/lib/validations/player';

interface PlayerListProps {
  teamId: string;
  players: Player[];
  isAdmin: boolean;
  onPlayersChange: () => void;
}

export function PlayerList({ teamId, players, isAdmin, onPlayersChange }: PlayerListProps) {
  const t = useTranslations('players');
  const [showForm, setShowForm] = useState(false);

  const handleCreatePlayer = async (data: CreatePlayerInput, avatarBlob?: Blob) => {
    await createPlayer(data, teamId, avatarBlob);
    setShowForm(false);
    onPlayersChange();
  };

  if (showForm) {
    return (
      <PlayerForm
        teamId={teamId}
        onSubmit={handleCreatePlayer}
        onCancel={() => setShowForm(false)}
      />
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-xl font-semibold">
          {t('list.title', { count: players.length })}
        </h2>
        {isAdmin && (
          <Button onClick={() => setShowForm(true)} className="h-12">
            <Plus className="mr-2 h-4 w-4" />
            {t('list.addButton')}
          </Button>
        )}
      </div>

      {players.length === 0 ? (
        <div className="text-center py-12">
          <Users className="mx-auto h-12 w-12 text-muted-foreground mb-4" />
          <h3 className="text-lg font-medium mb-2">{t('empty.title')}</h3>
          <p className="text-muted-foreground mb-6">{t('empty.description')}</p>
          {isAdmin && (
            <Button onClick={() => setShowForm(true)} size="lg" className="h-12">
              <Plus className="mr-2 h-5 w-5" />
              {t('empty.addButton')}
            </Button>
          )}
        </div>
      ) : (
        <div className="grid gap-3">
          {players.map((player) => (
            <PlayerCard key={player.id} player={player} />
          ))}
        </div>
      )}
    </div>
  );
}
```

NOTE: PlayerCard shows avatar, name/nickname, roles as badges, and jersey number. PlayerList shows grid of cards with empty state and add button for admins.
  </action>
  <verify>Components compile; Image component configured for external URLs</verify>
  <done>Player card and list components with avatar, roles, and jersey display</done>
</task>

<task type="auto">
  <name>Task 9: Create players page</name>
  <files>app/[locale]/teams/[teamId]/players/page.tsx</files>
  <action>
Create the players roster page:

```typescript
'use client';

import { useEffect, useState, useCallback } from 'react';
import { useParams } from 'next/navigation';
import { useTranslations } from 'next-intl';
import { getPlayersByTeam } from '@/lib/db/players';
import { getDB } from '@/lib/db';
import { PlayerList } from '@/components/players/player-list';
import { Button } from '@/components/ui/button';
import { ArrowLeft, Loader2 } from 'lucide-react';
import Link from 'next/link';
import type { Player } from '@/lib/db/schema';

export default function PlayersPage() {
  const t = useTranslations('players');
  const params = useParams();
  const teamId = params.teamId as string;

  const [players, setPlayers] = useState<Player[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isAdmin, setIsAdmin] = useState(false);

  const loadPlayers = useCallback(async () => {
    try {
      const data = await getPlayersByTeam(teamId);
      setPlayers(data);

      // Check if current user is admin (would need actual user ID from auth)
      // For now, assume admin for demo
      setIsAdmin(true);
    } catch (error) {
      console.error('Failed to load players:', error);
    } finally {
      setIsLoading(false);
    }
  }, [teamId]);

  useEffect(() => {
    loadPlayers();
  }, [loadPlayers]);

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-center py-12">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href={`/teams/${teamId}`}>
          <Button variant="ghost" className="pl-0">
            <ArrowLeft className="mr-2 h-4 w-4" />
            {t('backToTeam')}
          </Button>
        </Link>
      </div>

      <PlayerList
        teamId={teamId}
        players={players}
        isAdmin={isAdmin}
        onPlayersChange={loadPlayers}
      />
    </div>
  );
}
```

NOTE: Client component for interactivity. Loads players from IndexedDB. Back button to team page. isAdmin would come from auth context in real implementation.
  </action>
  <verify>Page compiles; dynamic route parameter handled correctly</verify>
  <done>Players roster page with loading state and player list</done>
</task>

<task type="auto">
  <name>Task 10: Add player translations</name>
  <files>
    messages/it.json
    messages/en.json
  </files>
  <action>
Add player-related translations to message files:

**messages/it.json - Add players section:**
```json
{
  "players": {
    "create": {
      "title": "Aggiungi giocatore"
    },
    "form": {
      "avatar": "Foto profilo",
      "name": "Nome",
      "namePlaceholder": "Es: Mario",
      "surname": "Cognome",
      "surnamePlaceholder": "Es: Rossi",
      "nickname": "Soprannome",
      "nicknamePlaceholder": "Es: SuperMario",
      "jerseyNumber": "Numero maglia",
      "roles": "Ruoli",
      "rolesHint": "Seleziona uno o più ruoli",
      "cancel": "Annulla",
      "save": "Salva giocatore",
      "saving": "Salvataggio..."
    },
    "avatar": {
      "upload": "Carica foto",
      "change": "Cambia foto",
      "cropTitle": "Ritaglia foto",
      "zoom": "Zoom",
      "cancel": "Annulla",
      "save": "Salva foto",
      "processing": "Elaborazione...",
      "hint": "JPG, PNG fino a 5MB",
      "errorType": "Seleziona un file immagine",
      "errorSize": "L'immagine non può superare i 5MB"
    },
    "roles": {
      "goalkeeper": "Portiere",
      "defender": "Difensore",
      "midfielder": "Centrocampista",
      "attacker": "Attaccante"
    },
    "list": {
      "title": "{count, plural, =0 {Nessun giocatore} one {# giocatore} other {# giocatori}}",
      "addButton": "Aggiungi giocatore"
    },
    "empty": {
      "title": "Nessun giocatore",
      "description": "Aggiungi i giocatori della tua squadra",
      "addButton": "Aggiungi primo giocatore"
    },
    "backToTeam": "Torna alla squadra"
  }
}
```

**messages/en.json - Add corresponding English translations.**

Add these keys to the existing JSON structure, maintaining proper nesting.
  </action>
  <verify>JSON is valid; no duplicate keys</verify>
  <done>Player translations added for form labels, roles, and UI text</done>
</task>

</tasks>

<verification>
After completion:
1. User can navigate to /teams/[teamId]/players
2. User can add player with name, surname, nickname, jersey number
3. Avatar upload shows cropper with zoom controls
4. Cropped avatar uploads to Supabase Storage
5. Role selector allows multiple positions
6. Player list displays with avatar, name, roles badges, jersey number
7. All text in Italian with English translations
</verification>

<success_criteria>
- Player creation form with all fields (TEAM-02)
- Avatar upload with client-side crop to square (TEAM-03)
- Multi-role assignment with toggle buttons (TEAM-04)
- Players display in list with complete info
- Offline-first with sync status tracking
- Responsive mobile design
</success_criteria>

<output>
After completion, create `.planning/phases/02-team-management/02-03-SUMMARY.md`
</output>
